<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Architecture</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Architecture</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="architecture-overview">Architecture overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>OpenShift Container Platform is a cloud-based Kubernetes container platform.
The foundation of OpenShift Container Platform is based on Kubernetes and therefore shares the same technology.
To learn more about OpenShift Container Platform and Kubernetes, see <a href="#architecture">product architecture</a>.</p>
</div>
<div class="sect2">
<h3 id="openshift-architecture-common-terms_architecture-overview">Glossary of common terms for OpenShift Container Platform architecture</h3>
<div class="paragraph">
<p>This glossary defines common terms that are used in the architecture content.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">access policies</dt>
<dd>
<p>A set of roles that dictate how users, applications, and entities within a cluster interacts with one another. An access policy increases cluster security.</p>
</dd>
<dt class="hdlist1">admission plugins</dt>
<dd>
<p>Admission plugins enforce security policies, resource limitations, or configuration requirements.</p>
</dd>
<dt class="hdlist1">authentication</dt>
<dd>
<p>To control access to an OpenShift Container Platform cluster, a cluster administrator can configure user authentication and ensure only approved users access the cluster. To interact with an OpenShift Container Platform cluster, you must authenticate to the OpenShift Container Platform API. You can authenticate by providing an OAuth access token or an X.509 client certificate in your requests to the OpenShift Container Platform API.</p>
</dd>
<dt class="hdlist1">bootstrap</dt>
<dd>
<p>A temporary machine that runs minimal Kubernetes and deploys the OpenShift Container Platform control plane.</p>
</dd>
<dt class="hdlist1">certificate signing requests (CSRs)</dt>
<dd>
<p>A resource requests a denoted signer to sign a certificate. This request might get approved or denied.</p>
</dd>
<dt class="hdlist1">Cluster Version Operator (CVO)</dt>
<dd>
<p>An Operator that checks with the OpenShift Container Platform Update Service to see the valid updates and update paths based on current component versions and information in the graph.</p>
</dd>
<dt class="hdlist1">compute nodes</dt>
<dd>
<p>Nodes that are responsible for executing workloads for cluster users. Compute nodes are also known as worker nodes.</p>
</dd>
<dt class="hdlist1">configuration drift</dt>
<dd>
<p>A situation where the configuration on a node does not match what the machine config specifies.</p>
</dd>
<dt class="hdlist1">containers</dt>
<dd>
<p>Lightweight and executable images that consist software and all its dependencies. Because containers virtualize the operating system, you can run containers anywhere, from a data center to a public or private cloud to your local host.</p>
</dd>
<dt class="hdlist1">container orchestration engine</dt>
<dd>
<p>Software that automates the deployment, management, scaling, and networking of containers.</p>
</dd>
<dt class="hdlist1">container workloads</dt>
<dd>
<p>Applications that are packaged and deployed in containers.</p>
</dd>
<dt class="hdlist1">control groups (cgroups)</dt>
<dd>
<p>Partitions sets of processes into groups to manage and limit the resources processes consume.</p>
</dd>
<dt class="hdlist1">control plane</dt>
<dd>
<p>A container orchestration layer that exposes the API and interfaces to define, deploy, and manage the life cycle of containers. Control planes are also known as control plane machines.</p>
</dd>
<dt class="hdlist1">CRI-O</dt>
<dd>
<p>A Kubernetes native container runtime implementation that integrates with the operating system to deliver an efficient Kubernetes experience.</p>
</dd>
<dt class="hdlist1">deployment</dt>
<dd>
<p>A Kubernetes resource object that maintains the life cycle of an application.</p>
</dd>
<dt class="hdlist1">Dockerfile</dt>
<dd>
<p>A text file that contains the user commands to perform on a terminal to assemble the image.</p>
</dd>
<dt class="hdlist1">hosted control planes</dt>
<dd>
<p>A OpenShift Container Platform feature that enables hosting a control plane on the OpenShift Container Platform cluster from its data plane and workers. This model performs following actions:</p>
<div class="ulist">
<ul>
<li>
<p>Optimize infrastructure costs required for the control planes.</p>
</li>
<li>
<p>Improve the cluster creation time.</p>
</li>
<li>
<p>Enable hosting the control plane using the Kubernetes native high level primitives. For example, deployments, stateful sets.</p>
</li>
<li>
<p>Allow a strong network segmentation between the control plane and workloads.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">hybrid cloud deployments</dt>
<dd>
<p>Deployments that deliver a consistent platform across bare metal, virtual, private, and public cloud environments. This offers speed, agility, and portability.</p>
</dd>
<dt class="hdlist1">Ignition</dt>
<dd>
<p>A utility that RHCOS uses to manipulate disks during initial configuration. It completes common disk tasks, including partitioning disks, formatting partitions, writing files, and configuring users.</p>
</dd>
<dt class="hdlist1">installer-provisioned infrastructure</dt>
<dd>
<p>The installation program deploys and configures the infrastructure that the cluster runs on.</p>
</dd>
<dt class="hdlist1">kubelet</dt>
<dd>
<p>A primary node agent that runs on each node in the cluster to ensure that containers are running in a pod.</p>
</dd>
<dt class="hdlist1">kubernetes manifest</dt>
<dd>
<p>Specifications of a Kubernetes API object in a JSON or YAML format. A configuration file can include deployments, config maps, secrets, daemon sets.</p>
</dd>
<dt class="hdlist1">Machine Config Daemon (MCD)</dt>
<dd>
<p>A daemon that regularly checks the nodes for configuration drift.</p>
</dd>
<dt class="hdlist1">Machine Config Operator (MCO)</dt>
<dd>
<p>An Operator that applies the new configuration to your cluster machines.</p>
</dd>
<dt class="hdlist1">machine config pools (MCP)</dt>
<dd>
<p>A group of machines, such as control plane components or user workloads, that are based on the resources that they handle.</p>
</dd>
<dt class="hdlist1">metadata</dt>
<dd>
<p>Additional information about cluster deployment artifacts.</p>
</dd>
<dt class="hdlist1">microservices</dt>
<dd>
<p>An approach to writing software. Applications can be separated into the smallest components, independent from each other by using microservices.</p>
</dd>
<dt class="hdlist1">mirror registry</dt>
<dd>
<p>A registry that holds the mirror of OpenShift Container Platform images.</p>
</dd>
<dt class="hdlist1">monolithic applications</dt>
<dd>
<p>Applications that are self-contained, built, and packaged as a single piece.</p>
</dd>
<dt class="hdlist1">namespaces</dt>
<dd>
<p>A namespace isolates specific system resources that are visible to all processes. Inside a namespace, only processes that are members of that namespace can see those resources.</p>
</dd>
<dt class="hdlist1">networking</dt>
<dd>
<p>Network information of OpenShift Container Platform cluster.</p>
</dd>
<dt class="hdlist1">node</dt>
<dd>
<p>A worker machine in the OpenShift Container Platform cluster. A node is either a virtual machine (VM) or a physical machine.</p>
</dd>
<dt class="hdlist1">OpenShift Container Platform Update Service (OSUS)</dt>
<dd>
<p>For clusters with internet access, Red Hat Enterprise Linux (RHEL) provides over-the-air updates by using an OpenShift Container Platform update service as a hosted service located behind public APIs.</p>
</dd>
<dt class="hdlist1">OpenShift CLI (<code>oc</code>)</dt>
<dd>
<p>A command line tool to run OpenShift Container Platform commands on the terminal.</p>
</dd>
<dt class="hdlist1">OpenShift Dedicated</dt>
<dd>
<p>A managed RHEL OpenShift Container Platform offering on Amazon Web Services (AWS) and Google Cloud Platform (GCP). OpenShift Dedicated focuses on building and scaling applications.</p>
</dd>
<dt class="hdlist1">OpenShift image registry</dt>
<dd>
<p>A registry provided by OpenShift Container Platform to manage images.</p>
</dd>
<dt class="hdlist1">Operator</dt>
<dd>
<p>The preferred method of packaging, deploying, and managing a Kubernetes application in an OpenShift Container Platform cluster. An Operator takes human operational knowledge and encodes it into software that is packaged and shared with customers.</p>
</dd>
<dt class="hdlist1">OperatorHub</dt>
<dd>
<p>A platform that contains various OpenShift Container Platform Operators to install.</p>
</dd>
<dt class="hdlist1">Operator Lifecycle Manager (OLM)</dt>
<dd>
<p>OLM helps you to install, update, and manage the lifecycle of Kubernetes native applications. OLM is an open source toolkit designed to manage Operators in an effective, automated, and scalable way.</p>
</dd>
<dt class="hdlist1">OSTree</dt>
<dd>
<p>An upgrade system for Linux-based operating systems that performs atomic upgrades of complete file system trees. OSTree tracks meaningful changes to the file system tree using an addressable object store, and is designed to complement existing package management systems.</p>
</dd>
<dt class="hdlist1">over-the-air (OTA) updates</dt>
<dd>
<p>The OpenShift Container Platform Update Service (OSUS) provides over-the-air updates to OpenShift Container Platform, including Red Hat Enterprise Linux CoreOS (RHCOS).</p>
</dd>
<dt class="hdlist1">pod</dt>
<dd>
<p>One or more containers with shared resources, such as volume and IP addresses, running in your OpenShift Container Platform cluster.
A pod is the smallest compute unit defined, deployed, and managed.</p>
</dd>
<dt class="hdlist1">private registry</dt>
<dd>
<p>OpenShift Container Platform can use any server implementing the container image registry API as a source of the image which allows the developers to push and pull their private container images.</p>
</dd>
<dt class="hdlist1">public registry</dt>
<dd>
<p>OpenShift Container Platform can use any server implementing the container image registry API as a source of the image which allows the developers to push and pull their public container images.</p>
</dd>
<dt class="hdlist1">RHEL OpenShift Container Platform Cluster Manager</dt>
<dd>
<p>A managed service where you can install, modify, operate, and upgrade your OpenShift Container Platform clusters.</p>
</dd>
<dt class="hdlist1">RHEL Quay Container Registry</dt>
<dd>
<p>A Quay.io container registry that serves most of the container images and Operators to OpenShift Container Platform clusters.</p>
</dd>
<dt class="hdlist1">replication controllers</dt>
<dd>
<p>An asset that indicates how many pod replicas are required to run at a time.</p>
</dd>
<dt class="hdlist1">role-based access control (RBAC)</dt>
<dd>
<p>A key security control to ensure that cluster users and workloads have only access to resources required to execute their roles.</p>
</dd>
<dt class="hdlist1">route</dt>
<dd>
<p>Routes expose a service to allow for network access to pods from users and applications outside the OpenShift Container Platform instance.</p>
</dd>
<dt class="hdlist1">scaling</dt>
<dd>
<p>The increasing or decreasing of resource capacity.</p>
</dd>
<dt class="hdlist1">service</dt>
<dd>
<p>A service exposes a running application on a set of pods.</p>
</dd>
<dt class="hdlist1">Source-to-Image (S2I) image</dt>
<dd>
<p>An image created based on the programming language of the application source code in OpenShift Container Platform to deploy applications.</p>
</dd>
<dt class="hdlist1">storage</dt>
<dd>
<p>OpenShift Container Platform supports many types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an OpenShift Container Platform cluster.</p>
</dd>
<dt class="hdlist1">Telemetry</dt>
<dd>
<p>A component to collect information such as size, health, and status of OpenShift Container Platform.</p>
</dd>
<dt class="hdlist1">template</dt>
<dd>
<p>A template describes a set of objects that can be parameterized and processed to produce a list of objects for creation by OpenShift Container Platform.</p>
</dd>
<dt class="hdlist1">user-provisioned infrastructure</dt>
<dd>
<p>You can install OpenShift Container Platform on the infrastructure that you provide. You can use the installation program to generate the assets required to provision the cluster infrastructure, create the cluster infrastructure, and then deploy the cluster to the infrastructure that you provided.</p>
</dd>
<dt class="hdlist1">web console</dt>
<dd>
<p>A user interface (UI) to manage OpenShift Container Platform.</p>
</dd>
<dt class="hdlist1">worker node</dt>
<dd>
<p>Nodes that are responsible for executing workloads for cluster users. Worker nodes are also known as compute nodes.</p>
</dd>
</dl>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p>For more information on networking, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/networking/#understanding-networking">OpenShift Container Platform networking</a>.</p>
</li>
<li>
<p>For more information on storage, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#index">OpenShift Container Platform storage</a>.</p>
</li>
<li>
<p>For more information on authentication, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/authentication_and_authorization/#index">OpenShift Container Platform authentication</a>.</p>
</li>
<li>
<p>For more information on Operator Lifecycle Manager (OLM), see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-understanding-olm">OLM</a>.</p>
</li>
<li>
<p>For more information on logging, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/logging/#viewing-resource-logs">OpenShift Container Platform Logging</a>.</p>
</li>
<li>
<p>For more information on over-the-air (OTA) updates, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/updating_clusters/#index">Updating OpenShift Container Platform clusters</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="about-installation-and-updates">About installation and updates</h3>
<div class="paragraph">
<p>As a cluster administrator, you can use the OpenShift Container Platform <a href="#architecture-installation">installation program</a> to install and deploy a cluster by using one of the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Installer-provisioned infrastructure</p>
</li>
<li>
<p>User-provisioned infrastructure</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="about-control-planes">About the control plane</h3>
<div class="paragraph">
<p>The <a href="#control-plane">control plane</a> manages the worker nodes and the pods in your cluster. You can configure nodes with the use of machine config pools (MCPs).
MCPs are groups of machines, such as control plane components or user workloads, that are based on the resources that they handle.
OpenShift Container Platform assigns different roles to hosts. These roles define the function of a machine in a cluster.
The cluster contains definitions for the standard control plane and worker role types.</p>
</div>
<div class="paragraph">
<p>You can use Operators to package, deploy, and manage services on the control plane.
Operators are important components in OpenShift Container Platform because they provide the following services:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Perform health checks</p>
</li>
<li>
<p>Provide ways to watch applications</p>
</li>
<li>
<p>Manage over-the-air updates</p>
</li>
<li>
<p>Ensure applications stay in the specified state</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="about-containerized-applications-for-developers">About containerized applications for developers</h3>
<div class="paragraph">
<p>As a developer, you can use different tools, methods, and formats to <a href="#understanding-development">develop your containerized application</a> based on your unique requirements, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use various build-tool, base-image, and registry options to build a simple container application.</p>
</li>
<li>
<p>Use supporting components such as OperatorHub and templates to develop your application.</p>
</li>
<li>
<p>Package and deploy your application as an Operator.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also create a Kubernetes manifest and store it in a Git repository.
Kubernetes works on basic units called pods. A pod is a single instance of a running process in your cluster. Pods can contain one or more containers.
You can create a service by grouping a set of pods and their access policies.
Services provide permanent internal IP addresses and host names for other applications to use as pods are created and destroyed. Kubernetes defines workloads based on the type of your application.</p>
</div>
</div>
<div class="sect2">
<h3 id="coreos-and-ignition">About Red Hat Enterprise Linux CoreOS (RHCOS) and Ignition</h3>
<div class="paragraph">
<p>As a cluster administrator, you can perform the following Red Hat Enterprise Linux CoreOS (RHCOS) tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Learn about the next generation of <a href="#architecture-rhcos">single-purpose container operating system technology</a>.</p>
</li>
<li>
<p>Choose how to configure Red Hat Enterprise Linux CoreOS (RHCOS)</p>
</li>
<li>
<p>Choose how to deploy Red Hat Enterprise Linux CoreOS (RHCOS):</p>
<div class="ulist">
<ul>
<li>
<p>Installer-provisioned deployment</p>
</li>
<li>
<p>User-provisioned deployment</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The OpenShift Container Platform installation program creates the Ignition configuration files that you need to deploy your cluster.
Red Hat Enterprise Linux CoreOS (RHCOS) uses Ignition during the initial configuration to perform common disk tasks, such as partitioning, formatting, writing files, and configuring users.
During the first boot, Ignition reads its configuration from the installation media or the location that you specify and applies the configuration to the machines.</p>
</div>
<div class="paragraph">
<p>You can learn how <a href="#architecture-rhcos">Ignition works</a>, the process for a Red Hat Enterprise Linux CoreOS (RHCOS) machine in an OpenShift Container Platform cluster, view Ignition configuration files, and change Ignition configuration after an installation.</p>
</div>
</div>
<div class="sect2">
<h3 id="about-admission-plug-ins">About admission plugins</h3>
<div class="paragraph">
<p>You can use <a href="#admission-plug-ins">admission plugins</a> to regulate how OpenShift Container Platform functions. After a resource request is authenticated and authorized, admission plugins intercept the resource request to the master API to validate resource requests and to ensure that scaling policies are adhered to.
Admission plugins are used to enforce security policies, resource limitations, or configuration requirements.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture">OpenShift Container Platform architecture</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="architecture-platform-introduction_architecture">Introduction to OpenShift Container Platform</h3>
<div class="paragraph">
<p>OpenShift Container Platform is a platform for developing and running containerized
applications. It is designed to allow applications and the data centers
that support them to expand from just a few machines and applications to
thousands of machines that serve millions of clients.</p>
</div>
<div class="paragraph">
<p>With its foundation in Kubernetes, OpenShift Container Platform incorporates the same
technology that serves as the engine for massive telecommunications, streaming
video, gaming, banking, and other applications. Its implementation in open
Red Hat technologies lets you extend your containerized applications beyond a
single cloud to on-premise and multi-cloud environments.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oke-arch-ocp-stack.png" alt="Red Hat OpenShift Kubernetes Engine">
</div>
</div>
<div class="sect3">
<h4 id="architecture-kubernetes-introduction_architecture">About Kubernetes</h4>
<div class="paragraph">
<p>Although container images and the containers that run from them are the
primary building blocks for modern application development, to run them at scale
requires a reliable and flexible distribution system. Kubernetes is the
defacto standard for orchestrating containers.</p>
</div>
<div class="paragraph">
<p>Kubernetes is an open source container orchestration engine for automating
deployment, scaling, and management of containerized applications. The general
concept of Kubernetes is fairly simple:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Start with one or more worker nodes to run the container workloads.</p>
</li>
<li>
<p>Manage the deployment of those workloads from one or more control plane nodes.</p>
</li>
<li>
<p>Wrap containers in a deployment unit called a pod. Using pods provides extra
metadata with the container and offers the ability to group several containers
in a single deployment entity.</p>
</li>
<li>
<p>Create special kinds of assets. For example, services are represented by a
set of pods and a policy that defines how they are accessed. This policy
allows containers to connect to the services that they need even if they do not
have the specific IP addresses for the services. Replication controllers are
another special asset that indicates how many pod replicas are required to run
at a time. You can use this capability to automatically scale your application
to adapt to its current demand.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In only a few years, Kubernetes has seen massive cloud and on-premise adoption.
The open source development model allows many people to extend Kubernetes
by implementing different technologies for components such as networking,
storage, and authentication.</p>
</div>
</div>
<div class="sect3">
<h4 id="architecture-container-application-benefits_architecture">The benefits of containerized applications</h4>
<div class="paragraph">
<p>Using containerized applications offers many advantages over using traditional deployment methods. Where applications were once expected to be installed on operating systems that included all their dependencies, containers let an application carry their dependencies with them. Creating containerized applications offers many benefits.</p>
</div>
<div class="sect4">
<h5 id="operating-system-benefits_architecture">Operating system benefits</h5>
<div class="paragraph">
<p>Containers use small, dedicated Linux operating systems without a kernel. Their file system, networking, cgroups, process tables, and namespaces are separate from the host Linux system, but the containers can integrate with the hosts seamlessly when necessary. Being based on Linux allows containers to use all the advantages that come with the open source development model of rapid innovation.</p>
</div>
<div class="paragraph">
<p>Because each container uses a dedicated operating system, you can deploy applications that require conflicting software dependencies on the same host. Each container carries its own dependent software and manages its own interfaces, such as networking and file systems, so applications never need to compete for those assets.</p>
</div>
</div>
<div class="sect4">
<h5 id="deployment-scaling-benefits_architecture">Deployment and scaling benefits</h5>
<div class="paragraph">
<p>If you employ rolling upgrades between major releases of your application, you can continuously improve your applications without downtime and still maintain compatibility with the current release.</p>
</div>
<div class="paragraph">
<p>You can also deploy and test a new version of an application alongside the existing version. If the container passes your tests, simply deploy more new containers and remove the old ones. </p>
</div>
<div class="paragraph">
<p>Since all the software dependencies for an application are resolved within the container itself, you can use a standardized operating system on each host in your data center. You do not need to configure a specific operating system for each application host. When your data center needs more capacity, you can deploy another generic host system.</p>
</div>
<div class="paragraph">
<p>Similarly, scaling containerized applications is simple. OpenShift Container Platform offers a simple, standard way of scaling any containerized service. For example, if you build applications as a set of microservices rather than large, monolithic applications, you can scale the individual microservices individually to meet demand. This capability allows you to scale only the required services instead of the entire application, which can allow you to meet application demands while using minimal resources.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="architecture-platform-benefits_architecture">OpenShift Container Platform overview</h4>
<div class="paragraph">
<p>OpenShift Container Platform provides enterprise-ready enhancements to Kubernetes, including the following enhancements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hybrid cloud deployments. You can deploy OpenShift Container Platform clusters to a variety of public cloud platforms or in your data center.</p>
</li>
<li>
<p>Integrated Red Hat technology. Major components in OpenShift Container Platform come from Red Hat Enterprise Linux (RHEL) and related Red Hat technologies. OpenShift Container Platform benefits from the intense testing and certification initiatives for Red Hat&#8217;s enterprise quality software.</p>
</li>
<li>
<p>Open source development model. Development is completed in the open, and the source code is available from public software repositories. This open collaboration fosters rapid innovation and development.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although Kubernetes excels at managing your applications, it does not specify
or manage platform-level requirements or deployment processes. Powerful and
flexible platform management tools and processes are important benefits that
OpenShift Container Platform 4.13 offers. The following sections describe some
unique features and benefits of OpenShift Container Platform.</p>
</div>
<div class="sect4">
<h5 id="architecture-custom-os_architecture">Custom operating system</h5>
<div class="paragraph">
<p>OpenShift Container Platform uses Red Hat Enterprise Linux CoreOS (RHCOS), a container-oriented operating system that is specifically designed for running containerized applications from OpenShift Container Platform and works with new tools to provide fast installation, Operator-based management, and simplified upgrades.</p>
</div>
<div class="paragraph">
<p>RHCOS includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignition, which OpenShift Container Platform uses as a firstboot system configuration for initially bringing up and configuring machines.</p>
</li>
<li>
<p>CRI-O, a Kubernetes native container runtime implementation that integrates closely with the operating system to deliver an efficient and optimized Kubernetes experience. CRI-O provides facilities for running, stopping, and restarting containers. It fully replaces the Docker Container Engine, which was used in OpenShift Container Platform 3.</p>
</li>
<li>
<p>Kubelet, the primary node agent for Kubernetes that is responsible for
launching and monitoring containers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, you must use RHCOS for all control
plane machines, but you can use Red Hat Enterprise Linux (RHEL) as the operating
system for compute machines, which are also known as worker machines. If you choose to use RHEL workers, you
must perform more system maintenance than if you use RHCOS for all of the
cluster machines.</p>
</div>
</div>
<div class="sect4">
<h5 id="architecture-platform-management_architecture">Simplified installation and update process</h5>
<div class="paragraph">
<p>With OpenShift Container Platform 4.13, if you have an account with the right
permissions, you can deploy a production cluster in supported clouds by running
a single command and providing a few values. You can also customize your cloud
installation or install your cluster in your data center if you use a supported
platform.</p>
</div>
<div class="paragraph">
<p>For clusters that use RHCOS for all machines, updating, or
upgrading, OpenShift Container Platform is a simple, highly-automated process. Because
OpenShift Container Platform completely controls the systems and services that run on each
machine, including the operating system itself, from a central control plane,
upgrades are designed to become automatic events. If your cluster contains
RHEL worker machines, the control plane benefits from the streamlined update
process, but you must perform more tasks to upgrade the RHEL machines.</p>
</div>
</div>
<div class="sect4">
<h5 id="architecture-key-features_architecture">Other key features</h5>
<div class="paragraph">
<p>Operators are both the fundamental unit of the OpenShift Container Platform 4.13
code base and a convenient way to deploy applications and software components
for your applications to use. In OpenShift Container Platform, Operators serve as the platform foundation and remove the need for manual upgrades of operating systems and control plane applications. OpenShift Container Platform Operators such as the
Cluster Version Operator and Machine Config Operator allow simplified,
cluster-wide management of those critical components.</p>
</div>
<div class="paragraph">
<p>Operator Lifecycle Manager (OLM) and the OperatorHub provide facilities for
storing and distributing Operators to people developing and deploying applications.</p>
</div>
<div class="paragraph">
<p>The Red Hat Quay Container Registry is a Quay.io container registry that serves
most of the container images and Operators to OpenShift Container Platform clusters.
Quay.io is a public registry version of Red Hat Quay that stores millions of images
and tags.</p>
</div>
<div class="paragraph">
<p>Other enhancements to Kubernetes in OpenShift Container Platform include improvements in
software defined networking (SDN), authentication, log aggregation, monitoring,
and routing. OpenShift Container Platform also offers a comprehensive web console and the
custom OpenShift CLI (<code>oc</code>) interface.</p>
</div>
</div>
<div class="sect4">
<h5 id="architecture-overview-image_architecture">OpenShift Container Platform lifecycle</h5>
<div class="paragraph">
<p>The following figure illustrates the basic OpenShift Container Platform lifecycle:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating an OpenShift Container Platform cluster</p>
</li>
<li>
<p>Managing the cluster</p>
</li>
<li>
<p>Developing and deploying applications</p>
</li>
<li>
<p>Scaling up applications</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/product-workflow-overview.png" alt="High-level OpenShift Container Platform flow">
</div>
<div class="title">Figure 1. High level OpenShift Container Platform overview</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cluster-entitlements_architecture">Internet access for OpenShift Container Platform</h4>
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, you require access to the internet to
install
your cluster.</p>
</div>
<div class="paragraph">
<p>You must have internet access to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access <a href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</a> to download the installation program and perform subscription management. If the cluster has internet access and you do not disable Telemetry, that service automatically entitles your cluster.</p>
</li>
<li>
<p>Access <a href="http://quay.io">Quay.io</a> to obtain the packages that are required to install your cluster.</p>
</li>
<li>
<p>Obtain the packages that are required to perform cluster updates.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>If your cluster cannot have direct internet access, you can perform a restricted network installation on some types of infrastructure that you provision. During that process, you download the required content and use it to populate a mirror registry with the installation packages. With some installation types, the environment that you install your cluster in will not require internet access. Before you update the cluster, you update the content of the mirror registry.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture-installation">Installation and update</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="installation-overview_architecture-installation">About OpenShift Container Platform installation</h3>
<div class="paragraph">
<p>The OpenShift Container Platform installation program offers four methods for deploying a cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Interactive</strong>: You can deploy a cluster with the web-based <a href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform/2022/html-single/assisted_installer_for_openshift_container_platform/index">Assisted Installer</a>. This is the recommended approach for clusters with networks connected to the internet. The Assisted Installer is the easiest way to install OpenShift Container Platform, it provides smart defaults, and it performs pre-flight validations before installing the cluster. It also provides a RESTful API for automation and advanced configuration scenarios.</p>
</li>
<li>
<p><strong>Local Agent-based</strong>: You can deploy a cluster locally with the agent-based installer for air-gapped or restricted networks. It provides many of the benefits of the Assisted Installer, but you must download and configure the <a href="https://console.redhat.com/openshift/install/metal/agent-based">agent-based installer</a> first. Configuration is done with a commandline interface. This approach is ideal for air-gapped or restricted networks.</p>
</li>
<li>
<p><strong>Automated</strong>: You can deploy a cluster on installer-provisioned infrastructure and the cluster it maintains. The installer uses each cluster host&#8217;s baseboard management controller (BMC) for provisioning. You can deploy clusters with both connected or air-gapped or restricted networks.</p>
</li>
<li>
<p><strong>Full control</strong>: You can deploy a cluster on infrastructure that you prepare and maintain, which provides maximum customizability. You can deploy clusters with both connected or air-gapped or restricted networks.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The clusters have the following characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Highly available infrastructure with no single points of failure is available by default.</p>
</li>
<li>
<p>Administrators maintain control over what updates are applied and when.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="about-the-installation-program">About the installation program</h4>
<div class="paragraph">
<p>You can use the installation program to deploy each type of cluster. The installation program generates main assets such as Ignition config files for the bootstrap, control plane (master), and worker machines. You can start an OpenShift Container Platform cluster with these three configurations and correctly configured infrastructure.</p>
</div>
<div class="paragraph">
<p>The OpenShift Container Platform installation program uses a set of targets and dependencies to manage cluster installations. The installation program has a set of targets that it must achieve, and each target has a set of dependencies. Because each target is only concerned with its own dependencies, the installation program can act to achieve multiple targets in parallel with the ultimate target being a running cluster. The installation program recognizes and uses existing components instead of running commands to create them again because the program meets dependencies.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/targets-and-dependencies.png" alt="OpenShift Container Platform installation targets and dependencies">
</div>
<div class="title">Figure 2. OpenShift Container Platform installation targets and dependencies</div>
</div>
</div>
<div class="sect3">
<h4 id="about-rhcos">About Red Hat Enterprise Linux CoreOS (RHCOS)</h4>
<div class="paragraph">
<p>Post-installation, each cluster machine uses Red Hat Enterprise Linux CoreOS (RHCOS) as the operating system. RHCOS is the immutable container host version of Red Hat Enterprise Linux (RHEL) and features a RHEL kernel with SELinux enabled by default. It includes the <code>kubelet</code>, which is the Kubernetes node agent, and the CRI-O container runtime, which is optimized for Kubernetes.</p>
</div>
<div class="paragraph">
<p>Every control plane machine in an OpenShift Container Platform 4.13 cluster must use RHCOS, which includes a critical first-boot provisioning tool called Ignition. This tool enables the cluster to configure the machines. Operating system updates are delivered as a bootable container image, using <strong>OSTree</strong> as a backend, that is deployed across the cluster by the Machine Config Operator. Actual operating system changes are made in-place on each machine as an atomic operation by using <strong>rpm-ostree</strong>. Together, these technologies enable OpenShift Container Platform to manage the operating system like it manages any other application on the cluster, by in-place upgrades that keep the entire platform up-to-date. These in-place updates can reduce the burden on operations teams.</p>
</div>
<div class="paragraph">
<p>If you use RHCOS as the operating system for all cluster machines, the cluster manages all aspects of its components and machines, including the operating system. Because of this, only the installation program and the Machine Config Operator can change machines. The installation program uses Ignition config files to set the exact state of each machine, and the Machine Config Operator completes more changes to the machines, such as the application of new certificates or keys, after installation.</p>
</div>
</div>
<div class="sect3">
<h4 id="supported-platforms-for-openshift-clusters_architecture-installation">Supported platforms for OpenShift Container Platform clusters</h4>
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, you can install a cluster that uses installer-provisioned infrastructure on the following platforms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Amazon Web Services (AWS)</p>
</li>
<li>
<p>Google Cloud Platform (GCP)</p>
</li>
<li>
<p>Microsoft Azure</p>
</li>
<li>
<p>Microsoft Azure Stack Hub</p>
</li>
<li>
<p>Red Hat OpenStack Platform (RHOSP) versions 16.1 and 16.2</p>
<div class="ulist">
<ul>
<li>
<p>The latest OpenShift Container Platform release supports both the latest RHOSP long-life release and intermediate release. For complete RHOSP release compatibility, see the <a href="https://access.redhat.com/articles/4679401">OpenShift Container Platform on RHOSP support matrix</a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>IBM Cloud VPC</p>
</li>
<li>
<p>Nutanix</p>
</li>
<li>
<p>Red Hat Virtualization (RHV)</p>
</li>
<li>
<p>VMware vSphere</p>
</li>
<li>
<p>Alibaba Cloud</p>
</li>
<li>
<p>Bare metal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For these clusters, all machines, including the computer that you run the installation process on, must have direct internet access to pull images for platform containers and provide telemetry data to Red Hat.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>After installation, the following changes are not supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mixing cloud provider platforms</p>
</li>
<li>
<p>Mixing cloud provider components, such as using a persistent storage framework from a differing platform than what the cluster is installed on</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, you can install a cluster that uses user-provisioned infrastructure on the following platforms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AWS</p>
</li>
<li>
<p>Azure</p>
</li>
<li>
<p>Azure Stack Hub</p>
</li>
<li>
<p>GCP</p>
</li>
<li>
<p>RHOSP versions 16.1 and 16.2</p>
</li>
<li>
<p>RHV</p>
</li>
<li>
<p>VMware vSphere</p>
</li>
<li>
<p>VMware Cloud on AWS</p>
</li>
<li>
<p>Bare metal</p>
</li>
<li>
<p>IBM Z or IBM&#174; LinuxONE</p>
</li>
<li>
<p>IBM Power</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on the supported cases for the platform, installations on user-provisioned infrastructure allow you to run machines with full internet access, place your cluster behind a proxy, or perform a <em>restricted network installation</em>. In a restricted network installation, you can download the images that are required to install a cluster, place them in a mirror registry, and use that data to install your cluster. While you require internet access to pull images for platform containers, with a restricted network installation on vSphere or bare metal infrastructure, your cluster machines do not require direct internet access.</p>
</div>
<div class="paragraph">
<p>The <a href="https://access.redhat.com/articles/4128421">OpenShift Container Platform 4.x Tested Integrations</a> page contains details about integration testing for different platforms.</p>
</div>
</div>
<div class="sect3">
<h4 id="installation-process_architecture-installation">Installation process</h4>
<div class="paragraph">
<p>Except for the Assisted Installer, when you install an OpenShift Container Platform cluster, you download the installation program from
the appropriate <a href="https://console.redhat.com/openshift/install">Infrastructure Provider</a> page on the OpenShift Cluster Manager site. This site manages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>REST API for accounts</p>
</li>
<li>
<p>Registry tokens, which are the pull secrets that you use to obtain the required components</p>
</li>
<li>
<p>Cluster registration, which associates the cluster identity to your Red Hat account to facilitate the gathering of usage metrics</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, the installation program is a Go binary file that performs a series of file transformations on a set of assets. The way you interact with the installation program differs depending on your installation type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To deploy a cluster with the Assisted Installer, you configure the cluster settings using the <a href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform/2022/html-single/assisted_installer_for_openshift_container_platform/index">Assisted Installer</a>. There is no installer to download and configure. After you complete the configuration, you download a discovery ISO and boot cluster machines with that image. You can install clusters with the Assisted Installer on Nutanix, vSphere, and bare metal with full integration, and other platforms without integration. If you install on bare metal, you must provide all of the cluster infrastructure and resources, including the networking, load balancing, storage, and individual cluster machines.</p>
</li>
<li>
<p>To deploy clusters with the agent-based installer, you download the <a href="https://console.redhat.com/openshift/install/metal/agent-based">agent-based installer</a> first. Then, you configure the cluster and generate a discovery image. You boot cluster machines with the discovery image, which installs an agent that communicates with the installation program and handles the provisioning for you instead of you interacting with the installation program or setting up a provisioner machine yourself. You must provide all of the cluster infrastructure and resources, including the networking, load balancing, storage, and individual cluster machines. This approach is ideal for air-gapped or restricted network environments.</p>
</li>
<li>
<p>For clusters with installer-provisioned infrastructure, you delegate the infrastructure bootstrapping and provisioning to the installation program instead of doing it yourself. The installation program creates all of the networking, machines, and operating systems that are required to support the cluster, except if you install on bare metal. If you install on bare metal, you must provide all of the cluster infrastructure and resources, including the bootstrap machine, networking, load balancing, storage, and individual cluster machines.</p>
</li>
<li>
<p>If you provision and manage the infrastructure for your cluster, you must provide all of the cluster infrastructure and resources, including the bootstrap machine, networking, load balancing, storage, and individual cluster machines.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The installer uses three sets of files during installation: an installation configuration file that is named <code>install-config.yaml</code>, Kubernetes manifests, and Ignition config files for your machine types.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible to modify Kubernetes and the Ignition config files that control the underlying RHCOS operating system during installation. However, no validation is available to confirm the suitability of any modifications that you make to these objects. If you modify these objects, you might render your cluster non-functional. Because of this risk, modifying Kubernetes and Ignition config files is not supported unless you are following documented procedures or are instructed to do so by Red Hat support.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The installation configuration file is transformed into Kubernetes manifests, and then the manifests are wrapped into Ignition config files. The installation program uses these Ignition config files to create the cluster.</p>
</div>
<div class="paragraph">
<p>The installation configuration files are all pruned when you run the installation program, so be sure to back up all configuration files that you want to use again.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot modify the parameters that you set during installation, but you can modify many cluster attributes after installation.</p>
</div>
</td>
</tr>
</table>
</div>
<h5 id="_the-installation-process-with-the-assisted-installer" class="discrete">The installation process with the Assisted Installer</h5>
<div class="paragraph">
<p>Installation with the <a href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform/2022/html-single/assisted_installer_for_openshift_container_platform/index">Assisted Installer</a> involves creating a cluster configuration interactively using the web-based user interface or using the RESTful API. The Assisted Installer user interface prompts you for required values and provides reasonable default values for the remaining parameters, unless you change them in the user interface or with the API.  The Assisted Installer generates a discovery image, which you download and use to boot the cluster machines. The image installs RHCOS and an agent, and the agent handles the provisioning for you. You can install OpenShift Container Platform with the Assisted Installer and full integration on Nutanix, vSphere, and bare metal, and on other platforms without integration.</p>
</div>
<div class="paragraph">
<p>OpenShift Container Platform manages all aspects of the cluster, including the operating system itself. Each machine boots with a configuration that references resources hosted in the cluster that it joins. This configuration allows the cluster to manage itself as updates are applied.</p>
</div>
<div class="paragraph">
<p>If possible, use this feature to avoid having to download and configure the agent-based installer.</p>
</div>
<h5 id="_the-installation-process-with-agent-based-infrastructure" class="discrete">The installation process with agent-based infrastructure</h5>
<div class="paragraph">
<p>Agent-based installation is similar to using the Assisted Installer, except that you download and install the <a href="https://console.redhat.com/openshift/install/metal/agent-based">agent-based installer</a> first. Agent-based installation is recommended when you want all the convenience of the Assisted Installer, but you need to install with an air-gapped or disconnected network.</p>
</div>
<div class="paragraph">
<p>If possible, use this feature to avoid having to create a provisioner machine with a bootstrap VM and provision and maintain the cluster infrastructure.</p>
</div>
<h5 id="_the-installation-process-with-installer-provisioned-infrastructure" class="discrete">The installation process with installer-provisioned infrastructure</h5>
<div class="paragraph">
<p>The default installation type uses installer-provisioned infrastructure. By default, the installation program acts as an installation wizard, prompting you for values that it cannot determine on its own and providing reasonable default values for the remaining parameters. You can also customize the installation process to support advanced infrastructure scenarios. The installation program provisions the underlying infrastructure for the cluster.</p>
</div>
<div class="paragraph">
<p>You can install either a standard cluster or a customized cluster. With a standard cluster, you provide minimum details that are required to install the cluster. With a customized cluster, you can specify more details about the platform, such as the number of machines that the control plane uses, the type of virtual machine that the cluster deploys, or the CIDR range for the Kubernetes service network.</p>
</div>
<div class="paragraph">
<p>If possible, use this feature to avoid having to provision and maintain the cluster infrastructure. In all other environments, you use the installation program to generate the assets that you require to provision your cluster infrastructure.</p>
</div>
<div class="paragraph">
<p>With installer-provisioned infrastructure clusters, OpenShift Container Platform manages all aspects of the cluster, including the operating system itself. Each machine boots with a configuration that references resources hosted in the cluster that it joins. This configuration allows the cluster to manage itself as updates are applied.</p>
</div>
<h5 id="_the-installation-process-with-user-provisioned-infrastructure" class="discrete">The installation process with user-provisioned infrastructure</h5>
<div class="paragraph">
<p>You can also install OpenShift Container Platform on infrastructure that you provide. You use the installation program to generate the assets that you require to provision the cluster infrastructure, create the cluster infrastructure, and then deploy the cluster to the infrastructure that you provided.</p>
</div>
<div class="paragraph">
<p>If you do not use infrastructure that the installation program provisioned, you must manage and maintain the cluster resources yourself, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The underlying infrastructure for the control plane and compute machines that make up the cluster</p>
</li>
<li>
<p>Load balancers</p>
</li>
<li>
<p>Cluster networking, including the DNS records and required subnets</p>
</li>
<li>
<p>Storage for the cluster infrastructure and applications</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If your cluster uses user-provisioned infrastructure, you have the option of adding RHEL compute machines to your cluster.</p>
</div>
<h5 id="_installation-process-details" class="discrete">Installation process details</h5>
<div class="paragraph">
<p>Because each machine in the cluster requires information about the cluster when it is provisioned, OpenShift Container Platform uses a temporary <em>bootstrap</em> machine during initial configuration to provide the required information to the permanent control plane. It boots by using an Ignition config file that describes how to create the cluster. The bootstrap machine creates the control plane machines that make up the control plane. The control plane machines then create the compute machines, which are also known as worker machines. The following figure illustrates this process:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/create-nodes.png" alt="Creating bootstrap" width="control plane" height="and compute machines">
</div>
<div class="title">Figure 3. Creating the bootstrap, control plane, and compute machines</div>
</div>
<div class="paragraph">
<p>After the cluster machines initialize, the bootstrap machine is destroyed. All clusters use the bootstrap process to initialize the cluster, but if you provision the infrastructure for your cluster, you must complete many of the steps manually.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending <code>node-bootstrapper</code> certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for <em>Recovering from expired control plane certificates</em> for more information.</p>
</li>
<li>
<p>It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bootstrapping a cluster involves the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The bootstrap machine boots and starts hosting the remote resources required for the control plane machines to boot. (Requires manual intervention if you provision the infrastructure)</p>
</li>
<li>
<p>The bootstrap machine starts a single-node etcd cluster and a temporary Kubernetes control plane.</p>
</li>
<li>
<p>The control plane machines fetch the remote resources from the bootstrap machine and finish booting. (Requires manual intervention if you provision the infrastructure)</p>
</li>
<li>
<p>The temporary control plane schedules the production control plane to the production control plane machines.</p>
</li>
<li>
<p>The Cluster Version Operator (CVO) comes online and installs the etcd Operator. The etcd Operator scales up etcd on all control plane nodes.</p>
</li>
<li>
<p>The temporary control plane shuts down and passes control to the production control plane.</p>
</li>
<li>
<p>The bootstrap machine injects OpenShift Container Platform components into the production control plane.</p>
</li>
<li>
<p>The installation program shuts down the bootstrap machine. (Requires manual intervention if you provision the infrastructure)</p>
</li>
<li>
<p>The control plane sets up the compute nodes.</p>
</li>
<li>
<p>The control plane installs additional services in the form of a set of Operators.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result of this bootstrapping process is a running OpenShift Container Platform cluster. The cluster then downloads and configures remaining components needed for the day-to-day operation, including the creation of compute machines in supported environments.</p>
</div>
<h4 id="_installation-scope" class="discrete">Installation scope</h4>
<div class="paragraph">
<p>The scope of the OpenShift Container Platform installation program is intentionally narrow. It is designed for simplicity and ensured success. You can complete many more configuration tasks after installation completes.</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p>See <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/post-installation_configuration/#available_cluster_customizations">Available cluster customizations</a> for details about OpenShift Container Platform configuration resources.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="update-service-about_architecture-installation">About the OpenShift Update Service</h3>
<div class="paragraph">
<p>The OpenShift Update Service (OSUS) provides update recommendations to OpenShift Container Platform, including Red Hat Enterprise Linux CoreOS (RHCOS). It provides a graph, or diagram, that contains the <em>vertices</em> of component Operators and the <em>edges</em> that connect them. The edges in the graph show which versions you can safely update to. The vertices are update payloads that specify the intended state of the managed cluster components.</p>
</div>
<div class="paragraph">
<p>The Cluster Version Operator (CVO) in your cluster checks with the OpenShift Update Service to see the valid updates and update paths based on current component versions and information in the graph. When you request an update, the CVO uses the release image for that update to upgrade your cluster. The release artifacts are hosted in Quay as container images.</p>
</div>
<div class="paragraph">
<p>To allow the OpenShift Update Service to provide only compatible updates, a release verification pipeline drives automation. Each release artifact is verified for compatibility with supported cloud platforms and system architectures, as well as other component packages. After the pipeline confirms the suitability of a release, the OpenShift Update Service notifies you that it is available.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The OpenShift Update Service displays all recommended updates for your current cluster.  If an update path is not recommended by the OpenShift Update Service, it might be because of a known issue with the update or the target release.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Two controllers run during continuous update mode. The first controller continuously updates the payload manifests, applies the manifests to the cluster, and outputs the controlled rollout status of the Operators to indicate whether they are available, upgrading, or failed. The second controller polls the OpenShift Update Service to determine if updates are available.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Only upgrading to a newer version is supported. Reverting or rolling back your cluster to a previous version is not supported. If your update fails, contact Red Hat support.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>During the update process, the Machine Config Operator (MCO) applies the new configuration to your cluster machines. The MCO cordons the number of nodes as specified by the <code>maxUnavailable</code> field on the machine configuration pool and marks them as unavailable. By default, this value is set to <code>1</code>. The MCO updates the affected nodes alphabetically by zone, based on the <code>topology.kubernetes.io/zone</code> label. If a zone has more than one node, the oldest nodes are updated first. For nodes that do not use zones, such as in bare metal deployments, the nodes are upgraded by age, with the oldest nodes updated first. The MCO updates the number of nodes as specified by the <code>maxUnavailable</code> field on the machine configuration pool at a time. The MCO then applies the new configuration and reboots the machine.</p>
</div>
<div class="paragraph">
<p>If you use Red Hat Enterprise Linux (RHEL) machines as workers, the MCO does not update the kubelet because you must update the OpenShift API on the machines first.</p>
</div>
<div class="paragraph">
<p>With the specification for the new version applied to the old kubelet, the RHEL machine cannot return to the <code>Ready</code> state. You cannot complete the update until the machines are available. However, the maximum number of unavailable nodes is set to ensure that normal cluster operations can continue with that number of machines out of service.</p>
</div>
<div class="paragraph">
<p>The OpenShift Update Service is composed of an Operator and one or more application instances.</p>
</div>
</div>
<div class="sect2">
<h3 id="unmanaged-operators_architecture-installation">Support policy for unmanaged Operators</h3>
<div class="paragraph">
<p>The <em>management state</em> of an Operator determines whether an Operator is actively
managing the resources for its related component in the cluster as designed. If
an Operator is set to an <em>unmanaged</em> state, it does not respond to changes in
configuration nor does it receive updates.</p>
</div>
<div class="paragraph">
<p>While this can be helpful in non-production clusters or during debugging,
Operators in an unmanaged state are unsupported and the cluster administrator
assumes full control of the individual component configurations and upgrades.</p>
</div>
<div class="paragraph">
<p>An Operator can be set to an unmanaged state using the following methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Individual Operator configuration</strong></p>
<div class="paragraph">
<p>Individual Operators have a <code>managementState</code> parameter in their configuration.
This can be accessed in different ways, depending on the Operator. For example,
the Red Hat OpenShift Logging Operator accomplishes this by modifying a custom resource
(CR) that it manages, while the Cluster Samples Operator uses a cluster-wide
configuration resource.</p>
</div>
<div class="paragraph">
<p>Changing the <code>managementState</code> parameter to <code>Unmanaged</code> means that the Operator
is not actively managing its resources and will take no action related to the
related component. Some Operators might not support this management state as it
might damage the cluster and require manual recovery.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Changing individual Operators to the <code>Unmanaged</code> state renders that particular
component and functionality unsupported. Reported issues must be reproduced in
<code>Managed</code> state for support to proceed.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><strong>Cluster Version Operator (CVO) overrides</strong></p>
<div class="paragraph">
<p>The <code>spec.overrides</code> parameter can be added to the CVO&#8217;s configuration to allow
administrators to provide a list of overrides to the CVO&#8217;s behavior for a
component. Setting the <code>spec.overrides[].unmanaged</code> parameter to <code>true</code> for a
component blocks cluster upgrades and alerts the administrator after a CVO
override has been set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">Disabling ownership via cluster version overrides prevents upgrades. Please remove overrides before continuing.</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Setting a CVO override puts the entire cluster in an unsupported state. Reported
issues must be reproduced after removing any overrides for support to proceed.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="architecture-installation-next-steps">Next steps</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installing-preparing">Selecting a cluster installation method and preparing it for users</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ocm-overview-ocp">Red Hat OpenShift Cluster Manager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Red Hat OpenShift Cluster Manager is a managed service where you can install, modify, operate, and upgrade your Red Hat OpenShift clusters. This service allows you to work with all of your organization’s clusters from a single dashboard.</p>
</div>
<div class="paragraph">
<p>OpenShift Cluster Manager guides you to install OpenShift Container Platform, Red Hat OpenShift Service on AWS (ROSA), and OpenShift Dedicated clusters. It is also responsible for managing both OpenShift Container Platform clusters after self-installation as well as your ROSA and OpenShift Dedicated clusters.</p>
</div>
<div class="paragraph">
<p>You can use OpenShift Cluster Manager to do the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create new clusters</p>
</li>
<li>
<p>View cluster details and metrics</p>
</li>
<li>
<p>Manage your clusters with tasks such as scaling, changing node labels, networking, authentication</p>
</li>
<li>
<p>Manage access control</p>
</li>
<li>
<p>Monitor clusters</p>
</li>
<li>
<p>Schedule upgrades</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="accessing-ocm_ocm-overview-ocp">Accessing Red Hat OpenShift Cluster Manager</h3>
<div class="paragraph">
<p>You can access OpenShift Cluster Manager with your configured OpenShift account.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You have an account that is part of an OpenShift organization.</p>
</li>
<li>
<p>If you are creating a cluster, your organization has specified quota.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Procedure</div>
<ul>
<li>
<p>Log in to <a href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</a> using your login credentials.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ocm-general-actions-ocp">General actions</h3>
<div class="paragraph">
<p>On the top right of the cluster page, there are some actions that a user can perform on the entire cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Open console</strong> launches a web console so that the cluster owner can issue commands to the cluster.</p>
</li>
<li>
<p><strong>Actions</strong> drop-down menu allows the cluster owner to rename the display name of the cluster, change the amount of load balancers and persistent storage on the cluster, if applicable, manually set the node count, and delete the cluster.</p>
</li>
<li>
<p><strong>Refresh</strong> icon forces a refresh of the cluster.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ocm-cluster-tabs-ocp">Cluster tabs</h3>
<div class="paragraph">
<p>Selecting an active, installed cluster shows tabs associated with that cluster. The following tabs display after the cluster&#8217;s installation completes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Access control</p>
</li>
<li>
<p>Add-ons</p>
</li>
<li>
<p>Networking</p>
</li>
<li>
<p>Insights Advisor</p>
</li>
<li>
<p>Machine pools</p>
</li>
<li>
<p>Support</p>
</li>
<li>
<p>Settings</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="ocm-overview-tab_ocm-overview-ocp">Overview tab</h4>
<div class="paragraph">
<p>The <strong>Overview</strong> tab provides information about how your cluster was configured:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cluster ID</strong> is the unique identification for the created cluster. This ID can be used when issuing commands to the cluster from the command line.</p>
</li>
<li>
<p><strong>Type</strong> shows the OpenShift version that the cluster is using.</p>
</li>
<li>
<p><strong>Region</strong> is the server region.</p>
</li>
<li>
<p><strong>Provider</strong> shows which cloud provider that the cluster was built upon.</p>
</li>
<li>
<p><strong>Availability</strong> shows which type of availability zone that the cluster uses, either single or multizone.</p>
</li>
<li>
<p><strong>Version</strong> is the OpenShift version that is installed on the cluster. If there is an update available, you can update from this field.</p>
</li>
<li>
<p><strong>Created at</strong> shows the date and time that the cluster was created.</p>
</li>
<li>
<p><strong>Owner</strong> identifies who created the cluster and has owner rights.</p>
</li>
<li>
<p><strong>Subscription type</strong> shows the subscription model that was selected on creation.</p>
</li>
<li>
<p><strong>Infrastructure type</strong> is the type of account that the cluster uses.</p>
</li>
<li>
<p><strong>Status</strong> displays the current status of the cluster.</p>
</li>
<li>
<p><strong>Total vCPU</strong> shows the total available virtual CPU for this cluster.</p>
</li>
<li>
<p><strong>Total memory</strong> shows the total available memory for this cluster.</p>
</li>
<li>
<p><strong>Load balancers</strong></p>
</li>
<li>
<p><strong>Persistent storage</strong> displays the amount of storage that is available on this cluster.</p>
</li>
<li>
<p><strong>Nodes</strong> shows the actual and desired nodes on the cluster. These numbers might not match due to cluster scaling.</p>
</li>
<li>
<p><strong>Network</strong> field shows the address and prefixes for network connectivity.</p>
</li>
<li>
<p><strong>Resource usage</strong> section of the tab displays the resources in use with a graph.</p>
</li>
<li>
<p><strong>Advisor recommendations</strong> section gives insight in relation to security, performance, availability, and stablility. This section requires the use of remote health functionality. See <a href="https://docs.openshift.com/container-platform/4.9/support/remote_health_monitoring/using-insights-to-identify-issues-with-your-cluster.html">Using Insights to identify issues with your cluster</a>.</p>
</li>
<li>
<p><strong>Cluster history</strong> section shows everything that has been done with the cluster including creation and when a new version is identified.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="ocm-accesscontrol-tab_ocm-overview-ocp">Access control tab</h4>
<div class="paragraph">
<p>The <strong>Access control</strong> tab allows the cluster owner to set up an identity provider, grant elevated permissions, and grant roles to other users.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You must be the cluster owner or have the correct permissions to grant roles on the cluster.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Select the <strong>Grant role</strong> button.</p>
</li>
<li>
<p>Enter the Red Hat account login for the user that you wish to grant a role on the cluster.</p>
</li>
<li>
<p>Select the <strong>Grant role</strong> button on the dialog box.</p>
</li>
<li>
<p>The dialog box closes, and the selected user shows the "Cluster Editor" access.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="ocm-addons-tab_ocm-overview-ocp">Add-ons tab</h4>
<div class="paragraph">
<p>The <strong>Add-ons</strong> tab displays all of the optional add-ons that can be added to the cluster. Select the desired add-on, and then select <strong>Install</strong> below the description for the add-on that displays.</p>
</div>
</div>
<div class="sect3">
<h4 id="ocm-insightsadvisor-tab_ocm-overview-ocp">Insights Advisor tab</h4>
<div class="paragraph">
<p>The <strong>Insights Advisor</strong> tab uses the Remote Health functionality of the OpenShift Container Platform to identify and mitigate risks to security, performance, availability, and stability. See <a href="https://docs.openshift.com/container-platform/latest/support/getting-support.html">Using Insights to identify issues with your cluster</a> in the OpenShift Container Platform documentation.</p>
</div>
</div>
<div class="sect3">
<h4 id="ocm-machinepools-tab_ocm-overview-ocp">Machine pools tab</h4>
<div class="paragraph">
<p>The <strong>Machine pools</strong> tab allows the cluster owner to create new machine pools, if there is enough available quota, or edit an existing machine pool.</p>
</div>
<div class="paragraph">
<p>Selecting the <strong>More options</strong> &gt; <strong>Scale</strong> opens the "Edit node count" dialog. In this dialog, you can change the node count per availability zone. If autoscaling is enabled, you can also set the range for autoscaling.</p>
</div>
</div>
<div class="sect3">
<h4 id="ocm-support-tab_ocm-overview-ocp">Support tab</h4>
<div class="paragraph">
<p>In the <strong>Support</strong> tab, you can add notification contacts for individuals that should receive cluster notifications. The username or email address that you provide must relate to a user account in the Red Hat organization where the cluster is deployed.</p>
</div>
<div class="paragraph">
<p>Also from this tab, you can open a support case to request technical support for your cluster.</p>
</div>
</div>
<div class="sect3">
<h4 id="ocm-settings-tab_ocm-overview-ocp">Settings tab</h4>
<div class="paragraph">
<p>The <strong>Settings</strong> tab provides a few options for the cluster owner:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Monitoring</strong>, which is enabled by default, allows for reporting done on user-defined actions. See <a href="https://docs.openshift.com/rosa/monitoring/osd-understanding-the-monitoring-stack.html">Understanding the monitoring stack</a>.</p>
</li>
<li>
<p><strong>Update strategy</strong> allows you to determine if the cluster automatically updates on a certain day of the week at a specified time or if all updates are scheduled manually.</p>
</li>
<li>
<p><strong>Node draining</strong> sets the duration that protected workloads are respected during updates. When this duration has passed, the node is forcibly removed.</p>
</li>
<li>
<p><strong>Update status</strong> shows the current version and if there are any updates available.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ocm-additional-resources-ocp">Additional resources</h3>
<div class="ulist">
<ul>
<li>
<p>For the complete documentation for OpenShift Cluster Manager, see <a href="https://access.redhat.com/documentation/en-us/openshift_cluster_manager/2022/html-single/managing_clusters/index">OpenShift Cluster Manager documentation</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mce-overview-ocp">About multicluster engine for Kubernetes operator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the challenges of scaling Kubernetes environments is managing the lifecycle of a growing fleet. To meet that challenge, you can use multicluster engine for Kubernetes operator (MCE). The operator delivers full lifecycle capabilities for managed OpenShift Container Platform clusters and partial lifecycle management for other Kubernetes distributions. It is available in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As a standalone operator that you install as part of your OpenShift Container Platform or OpenShift Kubernetes Engine subscription</p>
</li>
<li>
<p>As part of <a href="https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes">Red Hat Advanced Cluster Management for Kubernetes</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="mce-on-ocp">Cluster management with multicluster engine on OpenShift Container Platform</h3>
<div class="paragraph">
<p>When you enable multicluster engine on OpenShift Container Platform, you gain the following capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hosted-control-planes-overview_control-plane">Hosted control planes</a>, which is a feature that is based on the HyperShift project. With a centralized hosted control plane, you can operate OpenShift Container Platform clusters in a hyperscale manner.</p>
</li>
<li>
<p>Hive, which provisions self-managed OpenShift Container Platform clusters to the hub and completes the initial configurations for those clusters.</p>
</li>
<li>
<p>klusterlet agent, which registers managed clusters to the hub.</p>
</li>
<li>
<p>Infrastructure Operator, which manages the deployment of the Assisted Service to orchestrate on-premise bare metal and vSphere installations of OpenShift Container Platform, such as SNO on bare metal. The Infrastructure Operator includes <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/scalability_and_performance/#ztp-challenges-of-far-edge-deployments_ztp-deploying-far-edge-clusters-at-scale">GitOps Zero Touch Provisioning (ZTP)</a>, which fully automates cluster creation on bare metal and vSphere provisioning with GitOps workflows to manage deployments and configuration changes.</p>
</li>
<li>
<p>Open cluster management, which provides resources to manage Kubernetes clusters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The multicluster engine is included with your OpenShift Container Platform support subscription and is delivered separately from the core payload. To start to use multicluster engine, you deploy the OpenShift Container Platform cluster and then install the operator. For more information, see <a href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.8/html/clusters/cluster_mce_overview#mce-install-intro">Installing and upgrading multicluster engine operator</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mce-on-rhacm">Cluster management with Red Hat Advanced Cluster Management</h3>
<div class="paragraph">
<p>If you need cluster management capabilities beyond what OpenShift Container Platform with multicluster engine can provide, consider Red Hat Advanced Cluster Management. The multicluster engine is an integral part of Red Hat Advanced Cluster Management and is enabled by default.</p>
</div>
</div>
<div class="sect2">
<h3 id="mce-additional-resources-ocp">Additional resources</h3>
<div class="paragraph">
<p>For the complete documentation for multicluster engine, see <a href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.8/html/clusters/cluster_mce_overview#doc-wrapper">Cluster lifecycle with multicluster engine documentation</a>, which is part of the product documentation for Red Hat Advanced Cluster Management.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="control-plane">Control plane architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <em>control plane</em>, which is composed of control plane machines, manages the OpenShift Container Platform cluster. The control plane machines manage workloads on the compute machines, which are also known as worker machines. The cluster itself manages all upgrades to the machines by the actions of the Cluster Version Operator (CVO), the Machine Config Operator, and a set of individual Operators.</p>
</div>
<div class="sect2">
<h3 id="architecture-machine-config-pools_control-plane">Node configuration management with machine config pools</h3>
<div class="paragraph">
<p>Machines that run control plane components or user workloads are divided into groups based on the types of resources they handle. These groups of machines are called machine config pools (MCP). Each MCP manages a set of nodes and its corresponding machine configs. The role of the node determines which MCP it belongs to; the MCP governs nodes based on its assigned node role label. Nodes in an MCP have the same configuration; this means nodes can be scaled up and torn down in response to increased or decreased workloads.</p>
</div>
<div class="paragraph">
<p>By default, there are two MCPs created by the cluster when it is installed: <code>master</code> and <code>worker</code>. Each default MCP has a defined configuration applied by the Machine Config Operator (MCO), which is responsible for managing MCPs and facilitating MCP upgrades. You can create additional MCPs, or custom pools, to manage nodes that have custom use cases that extend outside of the default node types.</p>
</div>
<div class="paragraph">
<p>Custom pools are pools that inherit their configurations from the worker pool. They use any machine config targeted for the worker pool, but add the ability to deploy changes only targeted at the custom pool. Since a custom pool inherits its configuration from the worker pool, any change to the worker pool is applied to the custom pool as well. Custom pools that do not inherit their configurations from the worker pool are not supported by the MCO.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>A node can only be included in one MCP. If a node has multiple labels that correspond to several MCPs, like <code>worker,infra</code>, it is managed by the infra custom pool, not the worker pool. Custom pools take priority on selecting nodes to manage based on node labels; nodes that do not belong to a custom pool are managed by the worker pool.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is recommended to have a custom pool for every node role you want to manage in your cluster. For example, if you create infra nodes to handle infra workloads, it is recommended to create a custom infra MCP to group those nodes together. If you apply an <code>infra</code> role label to a worker node so it has the <code>worker,infra</code> dual label, but do not have a custom infra MCP, the MCO considers it a worker node. If you remove the <code>worker</code> label from a node and apply the <code>infra</code> label without grouping it in a custom pool, the node is not recognized by the MCO and is unmanaged by the cluster.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Any node labeled with the <code>infra</code> role that is only running infra workloads is not counted toward the total number of subscriptions. The MCP managing an infra node is mutually exclusive from how the cluster determines subscription charges; tagging a node with the appropriate <code>infra</code> role and using taints to prevent user workloads from being scheduled on that node are the only requirements for avoiding subscription charges for infra workloads.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The MCO applies updates for pools independently; for example, if there is an update that affects all pools, nodes from each pool update in parallel with each other. If you add a custom pool, nodes from that pool also attempt to update concurrently with the master and worker nodes.</p>
</div>
<div class="paragraph">
<p>There might be situations where the configuration on a node does not fully match what the currently-applied machine config specifies. This state is called <em>configuration drift</em>. The Machine Config Daemon (MCD) regularly checks the nodes for configuration drift. If the MCD detects configuration drift, the MCO marks the node <code>degraded</code> until an administrator corrects the node configuration. A degraded node is online and operational, but, it cannot be updated.</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/post-installation_configuration/#machine-config-drift-detection_post-install-machine-configuration-tasks">Understanding configuration drift detection</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="architecture-machine-roles_control-plane">Machine roles in OpenShift Container Platform</h3>
<div class="paragraph">
<p>OpenShift Container Platform assigns hosts different roles. These roles define the function of the machine within the cluster. The cluster contains definitions for the standard <code>master</code> and <code>worker</code> role types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The cluster also contains the definition for the <code>bootstrap</code> role. Because the bootstrap machine is used only during cluster installation, its function is explained in the cluster installation documentation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_control-plane-and-node-host-compatibility">Control plane and node host compatibility</h4>
<div class="paragraph">
<p>The OpenShift Container Platform version must match between control plane host and node host. For example, in a 4.13 cluster, all control plane hosts must be 4.13 and all nodes must be 4.13.</p>
</div>
<div class="paragraph">
<p>Temporary mismatches during cluster upgrades are acceptable. For example, when upgrading from OpenShift Container Platform 4.12 to 4.13, some nodes will upgrade to 4.13 before others. Prolonged skewing of control plane hosts and node hosts might expose older compute machines to bugs and missing features. Users should resolve skewed control plane hosts and node hosts as soon as possible.</p>
</div>
<div class="paragraph">
<p>The <code>kubelet</code> service must not be newer than <code>kube-apiserver</code>, and can be up to two minor versions older depending on whether your OpenShift Container Platform version is odd or even. The table below shows the appropriate version compatibility:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">OpenShift Container Platform version</th>
<th class="tableblock halign-left valign-top">Supported <code>kubelet</code> skew</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Odd OpenShift Container Platform minor versions <sup>[1]</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up to one version older</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Even OpenShift Container Platform minor versions <sup>[2]</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up to two versions older</p></td>
</tr>
</tbody>
</table>
<div class="openblock small">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For example, OpenShift Container Platform 4.11, 4.13.</p>
</li>
<li>
<p>For example, OpenShift Container Platform 4.10, 4.12.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="defining-workers_control-plane">Cluster workers</h4>
<div class="paragraph">
<p>In a Kubernetes cluster, the worker nodes are where the actual workloads requested by Kubernetes users run and are managed. The worker nodes advertise their capacity and the scheduler, which a control plane service, determines on which nodes to start pods and containers. Important services run on each worker node, including CRI-O, which is the container engine; Kubelet, which is the service that accepts and fulfills requests for running and stopping container workloads; a service proxy, which manages communication for pods across workers; and the runC or crun low-level container runtime, which creates and runs containers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>For information about how to enable crun instead of the default runC, see the documentation for creating a <code>ContainerRuntimeConfig</code> CR.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform, compute machine sets control the compute machines, which are assigned the <code>worker</code> machine role. Machines with the <code>worker</code> role drive compute workloads that are governed by a specific machine pool that autoscales them. Because OpenShift Container Platform has the capacity to support multiple machine types, the machines with the <code>worker</code> role are classed as <em>compute</em> machines. In this release, the terms <em>worker machine</em> and <em>compute machine</em> are used interchangeably because the only default type of compute machine is the worker machine. In future versions of OpenShift Container Platform, different types of compute machines, such as infrastructure machines, might be used by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Compute machine sets are groupings of compute machine resources under the <code>machine-api</code> namespace. Compute machine sets are configurations that are designed to start new compute machines on a specific cloud provider. Conversely, machine config pools (MCPs) are part of the Machine Config Operator (MCO) namespace. An MCP is used to group machines together so the MCO can manage their configurations and facilitate their upgrades.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="defining-masters_control-plane">Cluster control planes</h4>
<div class="paragraph">
<p>In a Kubernetes cluster, the <em>master</em> nodes run services that are required to control the Kubernetes cluster. In OpenShift Container Platform, the control plane is comprised of control plane machines that have a <code>master</code> machine role. They contain more than just the Kubernetes services for managing the OpenShift Container Platform cluster.</p>
</div>
<div class="paragraph">
<p>For most OpenShift Container Platform clusters, control plane machines are defined by a series of standalone machine API resources. For supported cloud provider and OpenShift Container Platform version combinations, control planes can be managed with control plane machine sets. Extra controls apply to control plane machines to prevent you from deleting all control plane machines and breaking your cluster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Exactly three control plane nodes must be used for all production deployments.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Services that fall under the Kubernetes category on the control plane include the Kubernetes API server, etcd, the Kubernetes controller manager, and the Kubernetes scheduler.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Kubernetes services that run on the control plane</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes API server validates and configures the data for pods, services,
and replication controllers. It also provides a focal point for the shared state of the cluster.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd stores the persistent control plane state while other components watch etcd for
changes to bring themselves into the specified state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes controller manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes controller manager watches etcd for changes to objects such as
replication, namespace, and service account controller objects, and then uses the
API to enforce the specified state. Several such processes create a cluster with
one active leader at a time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes scheduler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The Kubernetes scheduler watches for newly created pods without an assigned node and selects the best node to host the pod.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There are also OpenShift services that run on the control plane, which include the OpenShift API server, OpenShift controller manager, OpenShift OAuth API server, and OpenShift OAuth server.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. OpenShift services that run on the control plane</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift API server validates and configures the data for OpenShift resources, such as projects, routes, and templates.</p>
<p class="tableblock">The OpenShift API server is managed by the OpenShift API Server Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift controller manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift controller manager watches etcd for changes to OpenShift objects, such as project, route, and template controller objects, and then uses the API to enforce the specified state.</p>
<p class="tableblock">The OpenShift controller manager is managed by the OpenShift Controller Manager Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift OAuth API server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The OpenShift OAuth API server validates and configures the data to authenticate to OpenShift Container Platform, such as users, groups, and OAuth tokens.</p>
<p class="tableblock">The OpenShift OAuth API server is managed by the Cluster Authentication Operator.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenShift OAuth server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Users request tokens from the OpenShift OAuth server to authenticate themselves to the API.</p>
<p class="tableblock">The OpenShift OAuth server is managed by the Cluster Authentication Operator.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Some of these services on the control plane machines run as systemd services, while others run as static pods.</p>
</div>
<div class="paragraph">
<p>Systemd services are appropriate for services that you need to always come up on that particular system shortly after it starts. For control plane machines, those include sshd, which allows remote login. It also includes services such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The CRI-O container engine (crio), which runs and manages the containers. OpenShift Container Platform 4.13 uses CRI-O instead of the Docker Container Engine.</p>
</li>
<li>
<p>Kubelet (kubelet), which accepts requests for managing containers on the machine from control plane services.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CRI-O and Kubelet must run directly on the host as systemd services because they need to be running before you can run other containers.</p>
</div>
<div class="paragraph">
<p>The <code>installer-*</code> and <code>revision-pruner-*</code> control plane pods must run with root permissions because they write to the <code>/etc/kubernetes</code> directory, which is owned by the root user. These pods are in the following namespaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>openshift-etcd</code></p>
</li>
<li>
<p><code>openshift-kube-apiserver</code></p>
</li>
<li>
<p><code>openshift-kube-controller-manager</code></p>
</li>
<li>
<p><code>openshift-kube-scheduler</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operators-overview_control-plane">Operators in OpenShift Container Platform</h3>
<div class="paragraph">
<p>Operators are among the most important components of OpenShift Container Platform. Operators are the preferred method of packaging, deploying, and managing services on the control plane. They can also provide advantages to applications that users run.</p>
</div>
<div class="paragraph">
<p>Operators integrate with Kubernetes APIs and CLI tools such as <code>kubectl</code> and <code>oc</code> commands. They provide the means of monitoring applications, performing health checks, managing over-the-air (OTA) updates, and ensuring that applications remain in your specified state.</p>
</div>
<div class="paragraph">
<p>Operators also offer a more granular configuration experience. You configure each component by modifying the API that the Operator exposes instead of modifying a global configuration file.</p>
</div>
<div class="paragraph">
<p>Because CRI-O and the Kubelet run on every node, almost every other cluster function can be managed on the control plane by using Operators. Components that are added to the control plane by using Operators include critical networking and credential services.</p>
</div>
<div class="paragraph">
<p>While both follow similar Operator concepts and goals, Operators in OpenShift Container Platform are managed by two different systems, depending on their purpose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster Operators, which are managed by the Cluster Version Operator (CVO), are installed by default to perform cluster functions.</p>
</li>
<li>
<p>Optional add-on Operators, which are managed by Operator Lifecycle Manager (OLM), can be made accessible for users to run in their applications.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="cluster-operators_control-plane">Cluster Operators</h4>
<div class="paragraph">
<p>In OpenShift Container Platform, all cluster functions are divided into a series of default <em>cluster Operators</em>. Cluster Operators manage a particular area of cluster functionality, such as cluster-wide application logging, management of the Kubernetes control plane, or the machine provisioning system.</p>
</div>
<div class="paragraph">
<p>Cluster Operators are represented by a <code>ClusterOperator</code> object, which cluster administrators can view in the OpenShift Container Platform web console from the <strong>Administration</strong> &#8594; <strong>Cluster Settings</strong> page. Each cluster Operator provides a simple API for determining cluster functionality. The Operator hides the details of managing the lifecycle of that component. Operators can manage a single component or tens of components, but the end goal is always to reduce operational burden by automating common actions.</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#cluster-operators-ref">Cluster Operators reference</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="olm-operators_control-plane">Add-on Operators</h4>
<div class="paragraph">
<p>Operator Lifecycle Manager (OLM) and OperatorHub are default components in OpenShift Container Platform that help manage Kubernetes-native applications as Operators. Together they provide the system for discovering, installing, and managing the optional add-on Operators available on the cluster.</p>
</div>
<div class="paragraph">
<p>Using OperatorHub in the OpenShift Container Platform web console, cluster administrators and authorized users can select Operators to install from catalogs of Operators. After installing an Operator from OperatorHub, it can be made available globally or in specific namespaces to run in user applications.</p>
</div>
<div class="paragraph">
<p>Default catalog sources are available that include Red Hat Operators, certified Operators, and community Operators. Cluster administrators can also add their own custom catalog sources, which can contain a custom set of Operators.</p>
</div>
<div class="paragraph">
<p>Developers can use the Operator SDK to help author custom Operators that take advantage of OLM features, as well. Their Operator can then be bundled and added to a custom catalog source, which can be added to a cluster and made available to users.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>OLM does not manage the cluster Operators that comprise the OpenShift Container Platform architecture.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p>For more details on running add-on Operators in OpenShift Container Platform, see the <em>Operators</em> guide sections on <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-understanding-olm">Operator Lifecycle Manager (OLM)</a> and <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-understanding-operatorhub">OperatorHub</a>.</p>
</li>
<li>
<p>For more details on the Operator SDK, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#osdk-about">Developing Operators</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="platform-operators_control-plane">Platform Operators (Technology Preview)</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>The platform Operator type is a Technology Preview feature only. Technology Preview features
are not supported with Red Hat production service level agreements (SLAs) and
might not be functionally complete. Red Hat does not recommend using them
in production. These features provide early access to upcoming product
features, enabling customers to test functionality and provide feedback during
the development process.</p>
</div>
<div class="paragraph">
<p>For more information about the support scope of Red Hat Technology Preview features, see <a href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Operator Lifecycle Manager (OLM) introduces a new type of Operator called <em>platform Operators</em>. A platform Operator is an OLM-based Operator that can be installed during or after an OpenShift Container Platform cluster&#8217;s Day 0 operations and participates in the cluster&#8217;s lifecycle. As a cluster administrator, you can use platform Operators to further customize your OpenShift Container Platform installation to meet your requirements and use cases.</p>
</div>
<div class="paragraph">
<p>Using the existing cluster capabilities feature in OpenShift Container Platform, cluster administrators can already disable a subset of Cluster Version Operator-based (CVO) components considered non-essential to the initial payload prior to cluster installation. Platform Operators iterate on this model by providing additional customization options. Through the platform Operator mechanism, which relies on resources from the RukPak component, OLM-based Operators can now be installed at cluster installation time and can block cluster rollout if the Operator fails to install successfully.</p>
</div>
<div class="paragraph">
<p>In OpenShift Container Platform 4.12, this Technology Preview release focuses on the basic platform Operator mechanism and builds a foundation for expanding the concept in upcoming releases. You can use the cluster-wide <code>PlatformOperator</code> API to configure Operators before or after cluster creation on clusters that have enabled the <code>TechPreviewNoUpgrades</code> feature set.</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-managing-po">Managing platform Operators</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-po-techpreview_olm-managing-po">Technology Preview restrictions for platform Operators</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/operators/#olm-rukpak-about_olm-packaging-format">RukPak component and packaging format</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#cluster-capabilities">Cluster capabilities</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="about-machine-config-operator_control-plane">About the Machine Config Operator</h3>
<div class="paragraph">
<p>OpenShift Container Platform 4.13 integrates both
operating system and cluster management. Because the cluster manages its own
updates, including updates to Red Hat Enterprise Linux CoreOS (RHCOS) on cluster nodes,
OpenShift Container Platform provides an opinionated lifecycle management
experience that simplifies the orchestration of node upgrades.</p>
</div>
<div class="paragraph">
<p>OpenShift Container Platform employs three daemon sets and controllers to
simplify node management. These daemon sets orchestrate operating system updates
and configuration changes to the hosts by using standard Kubernetes-style
constructs. They include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>machine-config-controller</code>, which coordinates machine upgrades from the control
plane. It monitors all of the cluster nodes and orchestrates their configuration
updates.</p>
</li>
<li>
<p>The <code>machine-config-daemon</code> daemon set, which runs on
each node in the cluster and updates a machine to configuration as defined by
machine config and as instructed by the MachineConfigController. When the node detects
a change, it drains off its pods, applies the update, and reboots. These changes
come in the form of Ignition configuration files that apply the specified
machine configuration and control kubelet configuration. The update itself is
delivered in a container. This process is key to the success of managing
OpenShift Container Platform and RHCOS updates together.</p>
</li>
<li>
<p>The <code>machine-config-server</code> daemon set, which provides the Ignition config files
to control plane nodes as they join the cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The machine configuration is a subset of the Ignition configuration. The
<code>machine-config-daemon</code> reads the machine configuration to see if it needs to do
an OSTree update or if it must apply a series of systemd kubelet file changes,
configuration changes, or other changes to the operating system or OpenShift Container Platform
configuration.</p>
</div>
<div class="paragraph">
<p>When you perform node management operations, you create or modify a
<code>KubeletConfig</code> custom resource (CR).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>When changes are made to a machine configuration, the Machine Config Operator (MCO) automatically reboots all corresponding nodes in order for the changes to take effect.</p>
</div>
<div class="paragraph">
<p>To prevent the nodes from automatically rebooting after machine configuration changes, before making the changes, you must pause the autoreboot process by setting the <code>spec.paused</code> field to <code>true</code> in the corresponding machine config pool. When paused, machine configuration changes are not applied until you set the <code>spec.paused</code> field to <code>false</code> and the nodes have rebooted into the new configuration.</p>
</div>
<div class="paragraph">
<p>The following modifications do not trigger a node reboot:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the MCO detects any of the following changes, it applies the update without draining or rebooting the node:</p>
<div class="ulist">
<ul>
<li>
<p>Changes to the SSH key in the <code>spec.config.passwd.users.sshAuthorizedKeys</code> parameter of a machine config.</p>
</li>
<li>
<p>Changes to the global pull secret or pull secret in the <code>openshift-config</code> namespace.</p>
</li>
<li>
<p>Automatic rotation of the <code>/etc/kubernetes/kubelet-ca.crt</code> certificate authority (CA) by the Kubernetes API Server Operator.</p>
</li>
</ul>
</div>
</li>
<li>
<p>When the MCO detects changes to the <code>/etc/containers/registries.conf</code> file, such as adding or editing an <code>ImageDigestMirrorSet</code> or <code>ImageTagMirrorSet</code> object, it drains the corresponding nodes, applies the changes, and uncordons the nodes.The node drain does not happen for the following changes:</p>
<div class="ulist">
<ul>
<li>
<p>The addition of a registry with the <code>pull-from-mirror = "digest-only"</code> parameter set for each mirror.</p>
</li>
<li>
<p>The addition of a mirror with the <code>pull-from-mirror = "digest-only"</code> parameter set in a registry.</p>
</li>
<li>
<p>The addition of items to the <code>unqualified-search-registries</code> list.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There might be situations where the configuration on a node does not fully match what the currently-applied machine config specifies. This state is called <em>configuration drift</em>. The Machine Config Daemon (MCD) regularly checks the nodes for configuration drift. If the MCD detects configuration drift, the MCO marks the node <code>degraded</code> until an administrator corrects the node configuration. A degraded node is online and operational, but, it cannot be updated.</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p>For more information about detecting configuration drift, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/post-installation_configuration/#machine-config-drift-detection_post-install-machine-configuration-tasks">Understanding configuration drift detection</a>.</p>
</li>
<li>
<p>For information about preventing the control plane machines from rebooting after the Machine Config Operator makes changes to the machine configuration, see <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/support/#troubleshooting-disabling-autoreboot-mco_troubleshooting-operator-issues">Disabling Machine Config Operator from automatically rebooting</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="etcd-overview_control-plane">Overview of etcd</h3>
<div class="paragraph">
<p>etcd is a consistent, distributed key-value store that holds small amounts of data that can fit entirely in memory. Although etcd is a core component of many projects, it is the primary data store for Kubernetes, which is the standard system for container orchestration.</p>
</div>
<div class="sect3">
<h4 id="etcd-benefits_control-plane">Benefits of using etcd</h4>
<div class="paragraph">
<p>By using etcd, you can benefit in several ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maintain consistent uptime for your cloud-native applications, and keep them working even if individual servers fail</p>
</li>
<li>
<p>Store and replicate all cluster states for Kubernetes</p>
</li>
<li>
<p>Distribute configuration data to provide redundancy and resiliency for the configuration of nodes</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="etcd-architecture_control-plane">How etcd works</h4>
<div class="paragraph">
<p>To ensure a reliable approach to cluster configuration and management, etcd uses the etcd Operator. The Operator simplifies the use of etcd on a Kubernetes container platform like OpenShift Container Platform. With the etcd Operator, you can create or delete etcd members, resize clusters, perform backups, and upgrade etcd.</p>
</div>
<div class="paragraph">
<p>The etcd Operator observes, analyzes, and acts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It observes the cluster state by using the Kubernetes API.</p>
</li>
<li>
<p>It analyzes differences between the current state and the state that you want.</p>
</li>
<li>
<p>It fixes the differences through the etcd cluster management APIs, the Kubernetes API, or both.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>etcd holds the cluster state, which is constantly updated. This state is continuously persisted, which leads to a high number of small changes at high frequency. As a result, it is critical to back the etcd cluster member with fast, low-latency I/O. For more information about best practices for etcd, see "Recommended etcd practices".</p>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/scalability_and_performance/#recommended-etcd-practices">Recommended etcd practices</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/backup_and_restore/#backing-up-etcd">Backing up etcd</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hosted-control-planes-overview_control-plane">Introduction to hosted control planes (Technology Preview)</h3>
<div class="paragraph">
<p>You can use hosted control planes for Red Hat OpenShift Container Platform to reduce management costs, optimize cluster deployment time, and separate management and workload concerns so that you can focus on your applications.</p>
</div>
<div class="paragraph">
<p>You can enable hosted control planes as a Technology Preview feature by using the <a href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.8/html/clusters/cluster_mce_overview#cluster_mce_overview">multicluster engine for Kubernetes operator version 2.0 or later</a> on Amazon Web Services (AWS), bare metal by using the Agent provider, or OpenShift Virtualization.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Hosted control planes is a Technology Preview feature only. Technology Preview features
are not supported with Red Hat production service level agreements (SLAs) and
might not be functionally complete. Red Hat does not recommend using them
in production. These features provide early access to upcoming product
features, enabling customers to test functionality and provide feedback during
the development process.</p>
</div>
<div class="paragraph">
<p>For more information about the support scope of Red Hat Technology Preview features, see <a href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="hosted-control-planes-architecture_control-plane">Architecture of hosted control planes</h4>
<div class="paragraph">
<p>OpenShift Container Platform is often deployed in a coupled, or standalone, model, where a cluster consists of a control plane and a data plane. The control plane includes an API endpoint, a storage endpoint, a workload scheduler, and an actuator that ensures state. The data plane includes compute, storage, and networking where workloads and applications run.</p>
</div>
<div class="paragraph">
<p>The standalone control plane is hosted by a dedicated group of nodes, which can be physical or virtual, with a minimum number to ensure quorum. The network stack is shared. Administrator access to a cluster offers visibility into the cluster&#8217;s control plane, machine management APIs, and other components that contribute to the state of a cluster.</p>
</div>
<div class="paragraph">
<p>Although the standalone model works well, some situations require an architecture where the control plane and data plane are decoupled. In those cases, the data plane is on a separate network domain with a dedicated physical hosting environment. The control plane is hosted by using high-level primitives such as deployments and stateful sets that are native to Kubernetes. The control plane is treated as any other workload.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/hosted-control-planes-diagram.png" alt="Diagram that compares the hosted control plane model against OpenShift with a coupled control plane and workers">
</div>
</div>
</div>
<div class="sect3">
<h4 id="hosted-control-planes-benefits_control-plane">Benefits of hosted control planes</h4>
<div class="paragraph">
<p>With hosted control planes for OpenShift Container Platform, you can pave the way for a true hybrid-cloud approach and enjoy several other benefits.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The security boundaries between management and workloads are stronger because the control plane is decoupled and hosted on a dedicated hosting service cluster. As a result, you are less likely to leak credentials for clusters to other users. Because infrastructure secret account management is also decoupled, cluster infrastructure administrators cannot accidentally delete control plane infrastructure.</p>
</li>
<li>
<p>With hosted control planes, you can run many control planes on fewer nodes. As a result, clusters are more affordable.</p>
</li>
<li>
<p>Because the control planes consist of pods that are launched on OpenShift Container Platform, control planes start quickly. The same principles apply to control planes and workloads, such as monitoring, logging, and auto-scaling.</p>
</li>
<li>
<p>From an infrastructure perspective, you can push registries, HAProxy, cluster monitoring, storage nodes, and other infrastructure components to the tenant&#8217;s cloud provider account, isolating usage to the tenant.</p>
</li>
<li>
<p>From an operational perspective, multicluster management is more centralized, which results in fewer external factors that affect the cluster status and consistency. Site reliability engineers have a central place to debug issues and navigate to the cluster data plane, which can lead to shorter Time to Resolution (TTR) and greater productivity.</p>
</li>
</ul>
</div>
<div class="ulist _additional-resources">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.8/html/clusters/cluster_mce_overview#hypershift-addon-intro">HyperShift add-on (Technology Preview)</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.8/html/clusters/cluster_mce_overview#hosted-control-planes-intro">Hosted control planes (Technology Preview)</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="hosted-control-planes-concepts-personas_control-plane">Glossary of common concepts and personas for hosted control planes</h4>
<div class="paragraph">
<p>When you use hosted control planes for OpenShift Container Platform, it is important to understand its key concepts and the personas that are involved.</p>
</div>
<div class="sect4">
<h5 id="hosted-control-planes-concepts_control-plane">Concepts</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">hosted cluster</dt>
<dd>
<p>An OpenShift Container Platform API endpoint for the tenant cluster that is managed by the HyperShift Operator.</p>
</dd>
<dt class="hdlist1">hosted cluster infrastructure</dt>
<dd>
<p>Network, compute, and storage resources that exist in the tenant or end-user cloud account.</p>
</dd>
<dt class="hdlist1">hosted control plane</dt>
<dd>
<p>An OpenShift Container Platform control plane that runs on the management cluster, which is exposed by the API endpoint of a hosted cluster. The components of a control plane include etcd, the Kubernetes API server, the Kubernetes controller manager, and a VPN.</p>
</dd>
<dt class="hdlist1">hosting cluster</dt>
<dd>
<p>See <em>management cluster</em>.</p>
</dd>
<dt class="hdlist1">management cluster</dt>
<dd>
<p>An OpenShift Container Platform cluster where the HyperShift Operator is deployed and where the control planes for tenant clusters are hosted. The management cluster is synonymous with the <em>hosting cluster</em>.</p>
</dd>
<dt class="hdlist1">management cluster infrastructure</dt>
<dd>
<p>Network, compute, and storage resources of the management cluster.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="hosted-control-planes-personas_control-plane">Personas</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">cluster instance administrator</dt>
<dd>
<p>Users who assume this role are the equivalent of administrators in standalone OpenShift Container Platform. This user has the <code>cluster-admin</code> role in the provisioned cluster, but might not have power over when or how the cluster is updated or configured. This user might have read-only access to see some configuration projected into the cluster.</p>
</dd>
<dt class="hdlist1">cluster instance user</dt>
<dd>
<p>Users who assume this role are the equivalent of developers in standalone OpenShift Container Platform. This user does not have a view into OperatorHub or machines.</p>
</dd>
<dt class="hdlist1">cluster service consumer</dt>
<dd>
<p>Users who assume this role can request control planes and worker nodes, drive updates, or modify externalized configurations. Typically, this user does not manage or access cloud credentials or infrastructure encryption keys. The cluster service consumer persona can request hosted clusters and interact with node pools. Users who assume this role have RBAC to create, read, update, or delete hosted clusters and node pools within a logical boundary.</p>
</dd>
<dt class="hdlist1">cluster service provider</dt>
<dd>
<p>Users who assume this role typically have the <code>cluster-admin</code> role on the management cluster and have RBAC to monitor and own the availability of the HyperShift Operator as well as the control planes for the tenant&#8217;s hosted clusters. The cluster service provider persona is responsible for several activities, including the following examples:</p>
<div class="ulist">
<ul>
<li>
<p>Owning service-level objects for control plane availability, uptime, and stability</p>
</li>
<li>
<p>Configuring the cloud account for the management cluster to host control planes</p>
</li>
<li>
<p>Configuring the user-provisioned infrastructure, which includes the host awareness of available compute resources</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hosted-control-planes-version-support_control-plane">Versioning for hosted control planes</h4>
<div class="paragraph">
<p>With each major, minor, or patch version release of OpenShift Container Platform, two components of hosted control planes are released:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HyperShift Operator</p>
</li>
<li>
<p>Command-line interface (CLI)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The HyperShift Operator manages the lifecycle of hosted clusters that are represented by <code>HostedCluster</code> API resources. The HyperShift Operator is released with each OpenShift Container Platform release. After the HyperShift Operator is installed, it creates a config map called <code>supported-versions</code> in the HyperShift namespace, as shown in the following example. The config map describes the HostedCluster versions that can be deployed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">    apiVersion: v1
    data:
      supported-versions: '{"versions":["4.13","4.12","4.11"]}'
    kind: ConfigMap
    metadata:
      labels:
        hypershift.openshift.io/supported-versions: "true"
      name: supported-versions
      namespace: hypershift</code></pre>
</div>
</div>
<div class="paragraph">
<p>The CLI is a helper utility for development purposes. The CLI is released as part of any HyperShift Operator release. No compatibility policies are guaranteed.</p>
</div>
<div class="paragraph">
<p>The API, <code>hypershift.openshift.io</code>, provides a way to create and manage lightweight, flexible, heterogeneous OpenShift Container Platform clusters at scale. The API exposes two user-facing resources: <code>HostedCluster</code> and <code>NodePool</code>. A <code>HostedCluster</code> resource encapsulates the control plane and common data plane configuration. When you create a <code>HostedCluster</code> resource, you have a fully functional control plane with no attached nodes. A <code>NodePool</code> resource is a scalable set of worker nodes that is attached to a <code>HostedCluster</code> resource.</p>
</div>
<div class="paragraph">
<p>The API version policy generally aligns with the policy for <a href="https://kubernetes.io/docs/reference/using-api/#api-versioning">Kubernetes API versioning</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="understanding-development">Understanding OpenShift Container Platform development</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To fully leverage the capability of containers when developing and running
enterprise-quality applications, ensure your environment is supported by tools
that allow containers to be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Created as discrete microservices that can be connected to other
containerized, and non-containerized, services. For example, you might want to
join your application with a database or attach a monitoring application to it.</p>
</li>
<li>
<p>Resilient, so if a server crashes or needs to go down for maintenance or to be
decommissioned, containers can start on another machine.</p>
</li>
<li>
<p>Automated to pick up code changes automatically and then start and deploy new
versions of themselves.</p>
</li>
<li>
<p>Scaled up, or replicated, to have more instances serving clients as demand
increases and then spun down to fewer instances as demand declines.</p>
</li>
<li>
<p>Run in different ways, depending on the type of application. For example, one
application might run once a month to produce a report and then exit. Another
application might need to run constantly and be highly available to clients.</p>
</li>
<li>
<p>Managed so you can watch the state of your application and react when
something goes wrong.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Containers’ widespread acceptance, and the resulting requirements for tools and
methods to make them enterprise-ready, resulted in many options for them.</p>
</div>
<div class="paragraph">
<p>The rest of this section explains options for
assets you can create when you build and deploy containerized Kubernetes
applications in OpenShift Container Platform. It also describes which approaches you might
use for different kinds of applications and development requirements.</p>
</div>
<div class="sect2">
<h3 id="developing-containerized-applications">About developing containerized applications</h3>
<div class="paragraph">
<p>You can approach application development with containers in many ways, and
different approaches might be more appropriate for different situations. To
illustrate some of this variety, the series of approaches that is presented
starts with developing a single container and ultimately deploys that container
as a mission-critical application for a large enterprise. These approaches
show different tools, formats, and methods that you can employ with containerized
application development. This topic describes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Building a simple container and storing it in a registry</p>
</li>
<li>
<p>Creating a Kubernetes manifest and saving it to a Git repository</p>
</li>
<li>
<p>Making an Operator to share your application with others</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="building-simple-container">Building a simple container</h3>
<div class="paragraph">
<p>You have an idea for an application and you want to containerize it.</p>
</div>
<div class="paragraph">
<p>First you require a tool for building a container, like buildah or docker,
and a file that describes what goes in your container, which is typically a
<a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a>.</p>
</div>
<div class="paragraph">
<p>Next, you require a location to push the resulting container image so you can
pull it to run anywhere you want it to run. This location is a container
registry.</p>
</div>
<div class="paragraph">
<p>Some examples of each of these components are installed by default on most
Linux operating systems, except for the Dockerfile, which you provide yourself.</p>
</div>
<div class="paragraph">
<p>The following diagram displays the process of building and pushing an image:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/create-push-app.png" alt="Creating and pushing a containerized application">
</div>
<div class="title">Figure 4. Create a simple containerized application and push it to a registry</div>
</div>
<div class="paragraph">
<p>If you use a computer that runs Red Hat Enterprise Linux (RHEL) as the operating
system, the process of creating a containerized application requires the
following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Install container build tools: RHEL contains a set of tools that includes
podman, buildah, and skopeo that you use to build and manage containers.</p>
</li>
<li>
<p>Create a Dockerfile to combine base image and software: Information about
building your container goes into a file that is named <code>Dockerfile</code>. In that
file, you identify the base image you build from, the software packages you
install, and the software you copy into the container. You also identify
parameter values like network ports that you expose outside the container and
volumes that you mount inside the container. Put your Dockerfile and the
software you want to containerize in a directory on your RHEL system.</p>
</li>
<li>
<p>Run buildah or docker build: Run the <code>buildah build-using-dockerfile</code> or
the <code>docker build</code> command to pull your chosen base image to the local system and
create a container image that is stored locally. You can also build container images
without a Dockerfile by using buildah.</p>
</li>
<li>
<p>Tag and push to a registry: Add a tag to your new container image that
identifies the location of the registry in which you want to store and share
your container. Then push that image to the registry by running the
<code>podman push</code> or <code>docker push</code> command.</p>
</li>
<li>
<p>Pull and run the image: From any system that has a container client tool,
such as podman or docker, run a command that identifies your new image.
For example, run the <code>podman run &lt;image_name&gt;</code> or <code>docker run &lt;image_name&gt;</code>
command. Here <code>&lt;image_name&gt;</code> is the name of your new container image, which
resembles <code>quay.io/myrepo/myapp:latest</code>. The registry might require credentials
to push and pull images.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For more details on the process of building container images, pushing them to
registries, and running them, see
<a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/cicd/#custom-builds-buildah">Custom image builds with Buildah</a>.</p>
</div>
<div class="sect3">
<h4 id="container-build-tool-options">Container build tool options</h4>
<div class="paragraph">
<p>Building and managing containers with buildah, podman, and skopeo results in industry standard container images that include features specifically tuned for deploying containers in OpenShift Container Platform or other Kubernetes environments. These tools are daemonless and can run without root privileges, requiring less overhead to run them.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Support for Docker Container Engine as a container runtime is deprecated in Kubernetes 1.20 and will be removed in a future release. However, Docker-produced images will continue to work in your cluster with all runtimes, including CRI-O. For more information, see the <a href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/">Kubernetes blog announcement</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you ultimately run your containers in OpenShift Container Platform, you use the
<a href="https://cri-o.io/">CRI-O</a> container engine. CRI-O runs on every worker and
control plane machine in an OpenShift Container Platform cluster, but CRI-O is not yet supported as
a standalone runtime outside of OpenShift Container Platform.</p>
</div>
</div>
<div class="sect3">
<h4 id="base-image-options">Base image options</h4>
<div class="paragraph">
<p>The base image you choose to build your application on contains a set of
software that resembles a Linux system to your application. When you build your
own image, your software is placed into that file system and sees that file
system as though it were looking at its operating system. Choosing this base
image has major impact on how secure, efficient and upgradeable your container
is in the future.</p>
</div>
<div class="paragraph">
<p>Red Hat provides a new set of base images referred to as
<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/getting_started_with_containers/index#using_red_hat_base_container_images_standard_and_minimal">Red Hat Universal Base Images</a> (UBI).
These images are based on Red Hat Enterprise Linux and are similar to base
images that Red Hat has offered in the past, with one major difference: they
are freely redistributable without a Red Hat subscription. As a result, you can
build your application on UBI images without having to worry about how they
are shared or the need to create different images for different environments.</p>
</div>
<div class="paragraph">
<p>These UBI images have standard, init, and minimal versions. You can also use the
<a href="https://access.redhat.com/documentation/en-us/red_hat_software_collections/3/html-single/using_red_hat_software_collections_container_images/index">Red Hat Software Collections</a>
images as a foundation for applications that rely on specific runtime
environments such as Node.js, Perl, or Python. Special versions of some of
these runtime base images are referred to as Source-to-Image (S2I) images. With
S2I images, you can insert your code into a base image environment that is ready
to run that code.</p>
</div>
<div class="paragraph">
<p>S2I images are available for you to use directly from the OpenShift Container Platform web UI
by selecting <strong>Catalog</strong> &#8594; <strong>Developer Catalog</strong>, as shown in the following figure:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/developer-catalog.png" alt="OpenShift Container Platform Developer Catalog">
</div>
<div class="title">Figure 5. Choose S2I base images for apps that need specific runtimes</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding-development-registry-options">Registry options</h4>
<div class="paragraph">
<p>Container registries are where you store container images so you can share them
with others and make them available to the platform where they ultimately run.
You can select large, public container registries that offer free accounts or a
premium version that offer more storage and special features. You can also
install your own registry that can be exclusive to your organization or
selectively shared with others.</p>
</div>
<div class="paragraph">
<p>To get Red Hat images and certified partner images, you can draw from the
Red Hat Registry. The Red Hat Registry is represented by two locations:
<code>registry.access.redhat.com</code>, which is unauthenticated and deprecated, and
<code>registry.redhat.io</code>, which requires authentication. You can learn about the Red
Hat and partner images in the Red Hat Registry from the
<a href="https://catalog.redhat.com/software/containers/explore">Container images section of the Red Hat Ecosystem Catalog</a>.
Besides listing Red Hat container images, it also shows extensive information
about the contents and quality of those images, including health scores that are
based on applied security updates.</p>
</div>
<div class="paragraph">
<p>Large, public registries include <a href="https://hub.docker.com/">Docker Hub</a> and
<a href="https://quay.io/">Quay.io</a>. The Quay.io registry is owned and managed by Red
Hat. Many of the components used in OpenShift Container Platform are stored in Quay.io,
including container images and the Operators that are used to deploy
OpenShift Container Platform itself. Quay.io also offers the means of storing other types of
content, including Helm charts.</p>
</div>
<div class="paragraph">
<p>If you want your own, private container registry, OpenShift Container Platform itself
includes a private container registry that is installed with OpenShift Container Platform
and runs on its cluster. Red Hat also offers a private version of the Quay.io
registry called <a href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</a>.
Red Hat Quay includes geo replication, Git build triggers, Clair image scanning,
and many other features.</p>
</div>
<div class="paragraph">
<p>All of the registries mentioned here can require credentials to download images
from those registries. Some of those credentials are presented on a cluster-wide
basis from OpenShift Container Platform, while other credentials can be assigned to individuals.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating-kubernetes-manifest-openshift">Creating a Kubernetes manifest for OpenShift Container Platform</h3>
<div class="paragraph">
<p>While the container image is the basic building block for a containerized
application, more information is required to manage and deploy that application
in a Kubernetes environment such as OpenShift Container Platform. The typical next steps after
you create an image are to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Understand the different resources you work with in Kubernetes manifests</p>
</li>
<li>
<p>Make some decisions about what kind of an application you are running</p>
</li>
<li>
<p>Gather supporting components</p>
</li>
<li>
<p>Create a manifest and store that manifest in a Git repository so you can store
it in a source versioning system, audit it, track it, promote and deploy it
to the next environment, roll it back to earlier versions, if necessary, and
share it with others</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="understanding-kubernetes-pods">About Kubernetes pods and services</h4>
<div class="paragraph">
<p>While the container image is the basic unit with docker, the basic units that
Kubernetes works with are called
<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">pods</a>.
Pods represent the next step in building out an application. A pod can contain
one or more than one container. The key is that the pod is the single unit
that you deploy, scale, and manage.</p>
</div>
<div class="paragraph">
<p>Scalability and namespaces are probably the main items to consider when determining
what goes in a pod. For ease of deployment, you might want to deploy a container
in a pod and include its own logging and monitoring container in the pod. Later,
when you run the pod and need to scale up an additional instance, those other
containers are scaled up with it. For namespaces, containers in a pod share the
same network interfaces, shared storage volumes, and resource limitations,
such as memory and CPU, which makes it easier to manage the contents of the pod
as a single unit. Containers in a pod can also communicate with each other by
using standard inter-process communications, such as System V semaphores or
POSIX shared memory.</p>
</div>
<div class="paragraph">
<p>While individual pods represent a scalable unit in Kubernetes, a
<a href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a>
provides a means of grouping together a set of pods to create a complete, stable
application that can complete tasks such as load balancing. A service is also
more permanent than a pod because the service remains available from the same
IP address until you delete it. When the service is in use, it is requested by
name and the OpenShift Container Platform cluster resolves that name into the IP addresses
and ports where you can reach the pods that compose the service.</p>
</div>
<div class="paragraph">
<p>By their nature, containerized applications are separated from the operating
systems where they run and, by extension, their users. Part of your Kubernetes
manifest describes how to expose the application to internal and external
networks by defining
<a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">network policies</a>
that allow fine-grained control over communication with your containerized
applications. To connect incoming requests for HTTP, HTTPS, and other services
from outside your cluster to services inside your cluster, you can use an
<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/"><code>Ingress</code></a>
resource.</p>
</div>
<div class="paragraph">
<p>If your container requires on-disk storage instead of database storage, which
might be provided through a service, you can add
<a href="https://kubernetes.io/docs/concepts/storage/volumes/">volumes</a>
to your manifests to make that storage available to your pods. You can configure
the manifests to create persistent volumes (PVs) or dynamically create volumes that
are added to your <code>Pod</code> definitions.</p>
</div>
<div class="paragraph">
<p>After you define a group of pods that compose your application, you can define
those pods in
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"><code>Deployment</code></a>
and <a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/building_applications/#what-deployments-are"><code>DeploymentConfig</code></a> objects.</p>
</div>
</div>
<div class="sect3">
<h4 id="application-types">Application types</h4>
<div class="paragraph">
<p>Next, consider how your application type influences how to run it.</p>
</div>
<div class="paragraph">
<p>Kubernetes defines different types of workloads that are appropriate for
different kinds of applications. To determine the appropriate workload for your
application, consider if the application is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Meant to run to completion and be done. An example is an application that
starts up to produce a report and exits when the report is complete. The
application might not run again then for a month. Suitable OpenShift Container Platform
objects for these types of applications include
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"><code>Job</code></a>
and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/"><code>CronJob</code></a> objects.</p>
</li>
<li>
<p>Expected to run continuously. For long-running applications, you can write a
<a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/building_applications/#deployments-kube-deployments">deployment</a>.</p>
</li>
<li>
<p>Required to be highly available. If your application requires high
availability, then you want to size your deployment to have more than one
instance. A <code>Deployment</code> or <code>DeploymentConfig</code> object can incorporate a
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">replica set</a>
for that type of application. With replica sets, pods run across multiple nodes
to make sure the application is always available, even if a worker goes down.</p>
</li>
<li>
<p>Need to run on every node. Some types of Kubernetes applications are intended
to run in the cluster itself on every master or worker node. DNS and monitoring
applications are examples of applications that need to run continuously on every
node. You can run this type of application as a
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">daemon set</a>.
You can also run a daemon set on a subset of nodes, based on node labels.</p>
</li>
<li>
<p>Require life-cycle management. When you want to hand off your application so
that others can use it, consider creating an
<a href="https://www.openshift.com/learn/topics/operators">Operator</a>. Operators let you build in
intelligence, so it can handle things like backups and upgrades automatically.
Coupled with the Operator Lifecycle Manager (OLM), cluster managers can expose
Operators to selected namespaces so that users in the cluster can run them.</p>
</li>
<li>
<p>Have identity or numbering requirements. An application might have identity
requirements or numbering requirements. For example, you might be
required to run exactly three instances of the application and to name the
instances <code>0</code>, <code>1</code>, and <code>2</code>. A
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">stateful set</a>
is suitable for this application. Stateful sets are most useful for applications
that require independent storage, such as databases and zookeeper clusters.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="supporting-components">Available supporting components</h4>
<div class="paragraph">
<p>The application you write might need supporting components, like a database or
a logging component. To fulfill that need, you might be able to obtain the
required component from the following Catalogs that are available in the
OpenShift Container Platform web console:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OperatorHub, which is available in each OpenShift Container Platform 4.13
cluster. The OperatorHub makes Operators available from Red Hat,
certified Red Hat partners, and community members to the cluster operator. The
cluster operator can make those Operators available in all or selected
namespaces in the cluster, so developers can launch them and configure them
with their applications.</p>
</li>
<li>
<p>Templates, which are useful for a one-off type of application, where the
lifecycle of a component is not important after it is installed. A template provides an easy
way to get started developing a Kubernetes application with minimal overhead.
A template can be a list of resource definitions, which could be <code>Deployment</code>,
<code>Service</code>, <code>Route</code>, or other objects. If you want to change names or resources,
you can set these values as parameters in the template.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can configure the supporting Operators and
templates to the specific needs of your development team and then make them
available in the namespaces in which your developers work. Many people add
shared templates to the <code>openshift</code> namespace because it is accessible from all
other namespaces.</p>
</div>
</div>
<div class="sect3">
<h4 id="applying-manifest">Applying the manifest</h4>
<div class="paragraph">
<p>Kubernetes manifests let you create a more complete picture of the components
that make up your Kubernetes applications. You write these manifests as YAML
files and deploy them by applying them to the cluster, for example, by running
the <code>oc apply</code> command.</p>
</div>
</div>
<div class="sect3">
<h4 id="manifest-next-steps">Next steps</h4>
<div class="paragraph">
<p>At this point, consider ways to automate your container development process.
Ideally, you have some sort of CI pipeline that builds the images and pushes
them to a registry. In particular, a GitOps pipeline integrates your container
development with the Git repositories that you use to store the software that
is required to build your applications.</p>
</div>
<div class="paragraph">
<p>The workflow to this point might look like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Day 1: You write some YAML. You then run the <code>oc apply</code> command to apply that
YAML to the cluster and test that it works.</p>
</li>
<li>
<p>Day 2: You put your YAML container configuration file into your own Git
repository. From there, people who want to install that app, or help you improve
it, can pull down the YAML and apply it to their cluster to run the app.</p>
</li>
<li>
<p>Day 3: Consider writing an Operator for your application.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="develop-for-operators">Develop for Operators</h3>
<div class="paragraph">
<p>Packaging and deploying your application as an Operator might be preferred
if you make your application available for others to run. As noted earlier,
Operators add a lifecycle component to your application that acknowledges that
the job of running an application is not complete as soon as it is installed.</p>
</div>
<div class="paragraph">
<p>When you create an application as an Operator, you can build in your own
knowledge of how to run and maintain the application. You can build in features
for upgrading the application, backing it up, scaling it, or keeping track of
its state. If you configure the application correctly, maintenance tasks,
like updating the Operator, can happen automatically and invisibly to the
Operator&#8217;s users.</p>
</div>
<div class="paragraph">
<p>An example of a useful Operator is one that is set up to automatically back up
data at particular times. Having an Operator manage an application&#8217;s backup at
set times can save a system administrator from remembering to do it.</p>
</div>
<div class="paragraph">
<p>Any application maintenance that has traditionally been completed manually,
like backing up data or rotating certificates, can be completed automatically
with an Operator.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture-rhcos">Red Hat Enterprise Linux CoreOS (RHCOS)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="rhcos-about_architecture-rhcos">About RHCOS</h3>
<div class="paragraph">
<p>Red Hat Enterprise Linux CoreOS (RHCOS) represents the next generation of single-purpose container operating system technology by providing the quality standards of Red Hat Enterprise Linux (RHEL) with automated, remote upgrade features.</p>
</div>
<div class="paragraph">
<p>RHCOS is supported only as a component of OpenShift Container Platform 4.13 for all OpenShift Container Platform machines. RHCOS is the only supported operating system for OpenShift Container Platform control plane, or master, machines. While RHCOS is the default operating system for all cluster machines, you can create compute machines, which are also known as worker machines, that use RHEL as their operating system. There are two general ways RHCOS is deployed in OpenShift Container Platform 4.13:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you install your cluster on infrastructure that the installation program provisions, RHCOS images are downloaded to the target platform during installation. Suitable Ignition config files, which control the RHCOS configuration, are also downloaded and used to deploy the machines.</p>
</li>
<li>
<p>If you install your cluster on infrastructure that you manage, you must follow the installation documentation to obtain the RHCOS images, generate Ignition config files, and use the Ignition config files to provision your machines.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="rhcos-key-features_architecture-rhcos">Key RHCOS features</h4>
<div class="paragraph">
<p>The following list describes key features of the RHCOS operating system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Based on RHEL</strong>: The underlying operating system consists primarily of RHEL components. The same quality, security, and control measures that support RHEL also support RHCOS. For example, RHCOS software is in RPM packages, and each RHCOS system starts up with a RHEL kernel and a set of services that are managed by the systemd init system.</p>
</li>
<li>
<p><strong>Controlled immutability</strong>: Although it contains RHEL components, RHCOS is designed to be managed more tightly than a default RHEL installation. Management is performed remotely from the OpenShift Container Platform cluster. When you set up your RHCOS machines, you can modify only a few system settings. This controlled immutability allows OpenShift Container Platform to store the latest state of RHCOS systems in the cluster so it is always able to create additional machines and perform updates based on the latest RHCOS configurations.</p>
</li>
<li>
<p><strong>CRI-O container runtime</strong>: Although RHCOS contains features for running the OCI- and libcontainer-formatted containers that Docker requires, it incorporates the CRI-O container engine instead of the Docker container engine. By focusing on features needed by Kubernetes platforms, such as OpenShift Container Platform, CRI-O can offer specific compatibility with different Kubernetes versions. CRI-O also offers a smaller footprint and reduced attack surface than is possible with container engines that offer a larger feature set. At the moment, CRI-O is the only engine available within OpenShift Container Platform clusters.</p>
<div class="paragraph">
<p>CRI-O can use either the runC or crun container runtime to start and manage containers. For information about how to enable crun, see the documentation for creating a <code>ContainerRuntimeConfig</code> CR.</p>
</div>
</li>
<li>
<p><strong>Set of container tools</strong>: For tasks such as building, copying, and otherwise managing containers, RHCOS replaces the Docker CLI tool with a compatible set of container tools. The podman CLI tool supports many container runtime features, such as running, starting, stopping, listing, and removing containers and container images. The skopeo CLI tool can copy, authenticate, and sign images. You can use the <code>crictl</code> CLI tool to work with containers and pods from the CRI-O container engine. While direct use of these tools in RHCOS is discouraged, you can use them for debugging purposes.</p>
</li>
<li>
<p><strong>rpm-ostree upgrades</strong>: RHCOS features transactional upgrades using the <code>rpm-ostree</code> system. Updates are delivered by means of container images and are part of the OpenShift Container Platform update process. When deployed, the container image is pulled, extracted, and written to disk, then the bootloader is modified to boot into the new version. The machine will reboot into the update in a rolling manner to ensure cluster capacity is minimally impacted.</p>
</li>
<li>
<p><strong>bootupd firmware and bootloader updater</strong>: Package managers and hybrid systems such as <code>rpm-ostree</code> do not update the firmware or the bootloader. With <code>bootupd</code>, RHCOS users have access to a cross-distribution, system-agnostic update tool that manages firmware and boot updates in UEFI and legacy BIOS boot modes that run on modern architectures, such as x86_64, ppc64le, and aarch64.</p>
<div class="paragraph">
<p>For information about how to install <code>bootupd</code>, see the documentation for <em>Updating the bootloader using bootupd</em>.</p>
</div>
</li>
<li>
<p><strong>Updated through the Machine Config Operator</strong>: In OpenShift Container Platform, the Machine Config Operator handles operating system upgrades. Instead of upgrading individual packages, as is done with <code>yum</code> upgrades, <code>rpm-ostree</code> delivers upgrades of the OS as an atomic unit. The new OS deployment is staged during upgrades and goes into effect on the next reboot. If something goes wrong with the upgrade, a single rollback and reboot returns the system to the previous state. RHCOS upgrades in OpenShift Container Platform are performed during cluster updates.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For RHCOS systems, the layout of the <code>rpm-ostree</code> file system has the following characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/usr</code> is where the operating system binaries and libraries are stored and is read-only. We do not support altering this.</p>
</li>
<li>
<p><code>/etc</code>, <code>/boot</code>, <code>/var</code> are writable on the system but only intended to be altered by the Machine Config Operator.</p>
</li>
<li>
<p><code>/var/lib/containers</code> is the graph storage location for storing container images.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rhcos-configured_architecture-rhcos">Choosing how to configure RHCOS</h4>
<div class="paragraph">
<p>RHCOS is designed to deploy on an OpenShift Container Platform cluster with a minimal amount of user configuration. In its most basic form, this consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starting with a provisioned infrastructure, such as on AWS, or provisioning the infrastructure yourself.</p>
</li>
<li>
<p>Supplying a few pieces of information, such as credentials and cluster name, in an <code>install-config.yaml</code> file when running <code>openshift-install</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because RHCOS systems in OpenShift Container Platform are designed to be fully managed from the OpenShift Container Platform cluster after that, directly changing an RHCOS machine is discouraged. Although limited direct access to RHCOS machines cluster can be accomplished for debugging purposes, you should not directly configure RHCOS systems. Instead, if you need to add or change features on your OpenShift Container Platform nodes, consider making changes in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kubernetes workload objects, such as DaemonSet and Deployment</strong>: If you need to add services or other user-level features to your cluster, consider adding them as Kubernetes workload objects. Keeping those features outside of specific node configurations is the best way to reduce the risk of breaking the cluster on subsequent upgrades.</p>
</li>
<li>
<p><strong>Day-2 customizations</strong>: If possible, bring up a cluster without making any customizations to cluster nodes and make necessary node changes after the cluster is up. Those changes are easier to track later and less likely to break updates. Creating machine configs or modifying Operator custom resources are ways of making these customizations.</p>
</li>
<li>
<p><strong>Day-1 customizations</strong>: For customizations that you must implement when the cluster first comes up, there are ways of modifying your cluster so changes are implemented on first boot.
Day-1 customizations can be done through Ignition configs and manifest files during <code>openshift-install</code> or by adding boot options during ISO installs provisioned by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here are examples of customizations you could do on day 1:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Kernel arguments</strong>: If particular kernel features or tuning is needed on nodes when the cluster first boots.</p>
</li>
<li>
<p><strong>Disk encryption</strong>: If your security needs require that the root file system on the nodes are encrypted, such as with FIPS support.</p>
</li>
<li>
<p><strong>Kernel modules</strong>: If a particular hardware device, such as a network card or video card, does not have a usable module available by default in the Linux kernel.</p>
</li>
<li>
<p><strong>Chronyd</strong>: If you want to provide specific clock settings to your nodes, such as the location of time servers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To accomplish these tasks, you can augment the <code>openshift-install</code> process to include additional objects such as <code>MachineConfig</code> objects. Those procedures that result in creating machine configs can be passed to the Machine Config Operator after the cluster is up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending <code>node-bootstrapper</code> certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for <em>Recovering from expired control plane certificates</em> for more information.</p>
</li>
<li>
<p>It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="rhcos-deployed_architecture-rhcos">Choosing how to deploy RHCOS</h4>
<div class="paragraph">
<p>Differences between RHCOS installations for OpenShift Container Platform are based on whether you are deploying on an infrastructure provisioned by the installer or by the user:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Installer-provisioned</strong>: Some cloud environments offer pre-configured infrastructures that allow you to bring up an OpenShift Container Platform cluster with minimal configuration. For these types of installations, you can supply Ignition configs that place content on each node so it is there when the cluster first boots.</p>
</li>
<li>
<p><strong>User-provisioned</strong>: If you are provisioning your own infrastructure, you have more flexibility in how you add content to a RHCOS node. For example, you could add kernel arguments when you boot the RHCOS ISO installer to install each system. However, in most cases where configuration is required on the operating system itself, it is best to provide that configuration through an Ignition config.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Ignition facility runs only when the RHCOS system is first set up. After that, Ignition configs can be supplied later using the machine config.</p>
</div>
</div>
<div class="sect3">
<h4 id="rhcos-about-ignition_architecture-rhcos">About Ignition</h4>
<div class="paragraph">
<p>Ignition is the utility that is used by RHCOS to manipulate disks during initial configuration. It completes common disk tasks, including partitioning disks, formatting partitions, writing files, and configuring users. On first boot, Ignition reads its configuration from the installation media or the location that you specify and applies the configuration to the machines.</p>
</div>
<div class="paragraph">
<p>Whether you are installing your cluster or adding machines to it, Ignition always performs the initial configuration of the OpenShift Container Platform cluster machines. Most of the actual system setup happens on each machine itself. For each machine, Ignition takes the RHCOS image and boots the RHCOS kernel. Options on the kernel command line identify the type of deployment and the location of the Ignition-enabled initial RAM disk (initramfs).</p>
</div>
<div class="sect4">
<h5 id="about-ignition_architecture-rhcos">How Ignition works</h5>
<div class="paragraph">
<p>To create machines by using Ignition, you need Ignition config files. The OpenShift Container Platform installation program creates the Ignition config files that you need to deploy your cluster. These files are based on the information that you provide to the installation program directly or through an <code>install-config.yaml</code> file.</p>
</div>
<div class="paragraph">
<p>The way that Ignition configures machines is similar to how tools like <a href="https://cloud-init.io/">cloud-init</a> or Linux Anaconda <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/installation_guide/index#chap-kickstart-installations">kickstart</a> configure systems, but with some important differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignition runs from an initial RAM disk that is separate from the system you are installing to. Because of that, Ignition can repartition disks, set up file systems, and perform other changes to the machine&#8217;s permanent file system. In contrast, cloud-init runs as part of a machine init system when the system boots, so making foundational changes to things like disk partitions cannot be done as easily. With cloud-init, it is also difficult to reconfigure the boot process while you are in the middle of the node boot process.</p>
</li>
<li>
<p>Ignition is meant to initialize systems, not change existing systems. After a machine initializes and the kernel is running from the installed system, the Machine Config Operator from the OpenShift Container Platform cluster completes all future machine configuration.</p>
</li>
<li>
<p>Instead of completing a defined set of actions, Ignition implements a declarative configuration. It checks that all partitions, files, services, and other items are in place before the new machine starts. It then makes the changes, like copying files to disk that are necessary for the new machine to meet the specified configuration.</p>
</li>
<li>
<p>After Ignition finishes configuring a machine, the kernel keeps running but discards the initial RAM disk and pivots to the installed system on disk. All of the new system services and other features start without requiring a system reboot.</p>
</li>
<li>
<p>Because Ignition confirms that all new machines meet the declared configuration, you cannot have a partially configured machine. If a machine setup fails, the initialization process does not finish, and Ignition does not start the new machine. Your cluster will never contain partially configured machines. If Ignition cannot complete, the machine is not added to the cluster. You must add a new machine instead. This behavior prevents the difficult case of debugging a machine when the results of a failed configuration task are not known until something that depended on it fails at a later date.</p>
</li>
<li>
<p>If there is a problem with an Ignition config that causes the setup of a machine to fail, Ignition will not try to use the same config to set up another machine. For example, a failure could result from an Ignition config made up of a parent and child config that both want to create the same file. A failure in such a case would prevent that Ignition config from being used again to set up an other machines until the problem is resolved.</p>
</li>
<li>
<p>If you have multiple Ignition config files, you get a union of that set of configs. Because Ignition is declarative, conflicts between the configs could cause Ignition to fail to set up the machine. The order of information in those files does not matter. Ignition will sort and implement each setting in ways that make the most sense. For example, if a file needs a directory several levels deep, if another file needs a directory along that path, the later file is created first. Ignition sorts and creates all files, directories, and links by depth.</p>
</li>
<li>
<p>Because Ignition can start with a completely empty hard disk, it can do something cloud-init cannot do: set up systems on bare metal from scratch using features such as PXE boot. In the bare metal case, the Ignition config is injected into the boot partition so that Ignition can find it and configure the system correctly.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="ignition-sequence_architecture-rhcos">The Ignition sequence</h5>
<div class="paragraph">
<p>The Ignition process for an RHCOS machine in an OpenShift Container Platform cluster involves the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The machine gets its Ignition config file. Control plane machines get their Ignition config files from the bootstrap machine, and worker machines get Ignition config files from a control plane machine.</p>
</li>
<li>
<p>Ignition creates disk partitions, file systems, directories, and links on the machine. It supports RAID arrays but does not support LVM volumes.</p>
</li>
<li>
<p>Ignition mounts the root of the permanent file system to the <code>/sysroot</code> directory in the initramfs and starts working in that <code>/sysroot</code> directory.</p>
</li>
<li>
<p>Ignition configures all defined file systems and sets them up to mount appropriately at runtime.</p>
</li>
<li>
<p>Ignition runs <code>systemd</code> temporary files to populate required files in the <code>/var</code> directory.</p>
</li>
<li>
<p>Ignition runs the Ignition config files to set up users, systemd unit files, and other configuration files.</p>
</li>
<li>
<p>Ignition unmounts all components in the permanent system that were mounted in the initramfs.</p>
</li>
<li>
<p>Ignition starts up the init process of the new machine, which in turn starts up all other services on the machine that run during system boot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At the end of this process, the machine is ready to join the cluster and does not require a reboot.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ignition-config-viewing_architecture-rhcos">Viewing Ignition configuration files</h3>
<div class="paragraph">
<p>To see the Ignition config file used to deploy the bootstrap machine, run the
following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ openshift-install create ignition-configs --dir $HOME/testconfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you answer a few questions, the <code>bootstrap.ign</code>, <code>master.ign</code>, and
<code>worker.ign</code> files appear in the directory you entered.</p>
</div>
<div class="paragraph">
<p>To see the contents of the <code>bootstrap.ign</code> file, pipe it through the <code>jq</code> filter.
Here&#8217;s a snippet from that file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ cat $HOME/testconfig/bootstrap.ign | jq
{
  "ignition": {
    "version": "3.2.0"
  },
  "passwd": {
    "users": [
      {
        "name": "core",
        "sshAuthorizedKeys": [
          "ssh-rsa AAAAB3NzaC1yc...."
        ]
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": false,
        "path": "/etc/motd",
        "user": {
          "name": "root"
        },
        "append": [
          {
            "source": "data:text/plain;charset=utf-8;base64,VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg=="
          }
        ],
        "mode": 420
      },
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>To decode the contents of a file listed in the <code>bootstrap.ign</code> file, pipe the
base64-encoded data string representing the contents of that file to the <code>base64
-d</code> command. Here&#8217;s an example using the contents of the <code>/etc/motd</code> file added to
the bootstrap machine from the output shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ echo VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg== | base64 --decode</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">This is the bootstrap node; it will be destroyed when the master is fully up.

The primary services are release-image.service followed by bootkube.service. To watch their status, run e.g.

  journalctl -b -f -u release-image.service -u bootkube.service</code></pre>
</div>
</div>
<div class="paragraph">
<p>Repeat those commands on the <code>master.ign</code> and <code>worker.ign</code> files to see the source
of Ignition config files for each of those machine types.  You should see a line
like the following for the <code>worker.ign</code>, identifying how it gets its Ignition
config from the bootstrap machine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">"source": "https://api.myign.develcluster.example.com:22623/config/worker",</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are a few things you can learn from the <code>bootstrap.ign</code> file:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Format: The format of the file is defined in the
<a href="https://coreos.github.io/ignition/configuration-v3_2/">Ignition config spec</a>.
Files of the same format are used later by the MCO to merge changes into a
machine&#8217;s configuration.</p>
</li>
<li>
<p>Contents: Because the bootstrap machine serves the Ignition configs for other
machines, both master and worker machine Ignition config information is stored in the
<code>bootstrap.ign</code>, along with the bootstrap machine&#8217;s configuration.</p>
</li>
<li>
<p>Size: The file is more than 1300 lines long, with path to various types of resources.</p>
</li>
<li>
<p>The content of each file that will be copied to the machine is actually encoded
into data URLs, which tends to make the content a bit clumsy to read. (Use the
  <code>jq</code> and <code>base64</code> commands shown previously to make the content more readable.)</p>
</li>
<li>
<p>Configuration: The different sections of the Ignition config file are generally
meant to contain files that are just dropped into a machine&#8217;s file system, rather
than commands to modify existing files. For example, instead of having a section
on NFS that configures that service, you would just add an NFS configuration
file, which would then be started by the init process when the system comes up.</p>
</li>
<li>
<p>users: A user named <code>core</code> is created, with your SSH key assigned to that user.
This allows you to log in to the cluster with that user name and your
credentials.</p>
</li>
<li>
<p>storage: The storage section identifies files that are added to each machine. A
few notable files include <code>/root/.docker/config.json</code> (which provides credentials
  your cluster needs to pull from container image registries) and a bunch of
  manifest files in <code>/opt/openshift/manifests</code> that are used to configure your cluster.</p>
</li>
<li>
<p>systemd: The <code>systemd</code> section holds content used to create <code>systemd</code> unit files.
Those files are used to start up services at boot time, as well as manage those
services on running systems.</p>
</li>
<li>
<p>Primitives: Ignition also exposes low-level primitives that other tools can
build on.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="digging-into-machine-config_architecture-rhcos">Changing Ignition configs after installation</h3>
<div class="paragraph">
<p>Machine config pools manage a cluster of nodes and their corresponding machine
configs. Machine configs contain configuration information for a cluster.
To list all machine config pools that are known:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc get machineconfigpools</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">NAME   CONFIG                                  UPDATED UPDATING DEGRADED
master master-1638c1aea398413bb918e76632f20799 False   False    False
worker worker-2feef4f8288936489a5a832ca8efe953 False   False    False</code></pre>
</div>
</div>
<div class="paragraph">
<p>To list all machine configs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc get machineconfig</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">NAME                                      GENERATEDBYCONTROLLER   IGNITIONVERSION   CREATED   OSIMAGEURL

00-master                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-master-ssh                             4.0.0-0.150.0.0-dirty                     16m
00-worker                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-worker-ssh                             4.0.0-0.150.0.0-dirty                     16m
01-master-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
01-worker-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
master-1638c1aea398413bb918e76632f20799   4.0.0-0.150.0.0-dirty   3.2.0             16m
worker-2feef4f8288936489a5a832ca8efe953   4.0.0-0.150.0.0-dirty   3.2.0             16m</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Machine Config Operator acts somewhat differently than Ignition when it
comes to applying these machine configs. The machine configs are read in order
(from 00* to 99*). Labels inside the machine configs identify the type of node
each is for (master or worker). If the same file appears in multiple
machine config files, the last one wins. So, for example, any file that appears
in a 99* file would replace the same file that appeared in a 00* file.
The input <code>MachineConfig</code> objects are unioned into a "rendered" <code>MachineConfig</code>
object, which will be used as a target by the operator and is the value you
can see in the machine config pool.</p>
</div>
<div class="paragraph">
<p>To see what files are being managed from a machine config, look for "Path:"
inside a particular <code>MachineConfig</code> object. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc describe machineconfigs 01-worker-container-runtime | grep Path:</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example output</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">            Path:            /etc/containers/registries.conf
            Path:            /etc/containers/storage.conf
            Path:            /etc/crio/crio.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be sure to give the machine config file a later name
(such as 10-worker-container-runtime). Keep in mind that the content of each
file is in URL-style data. Then apply the new machine config to the cluster.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="admission-plug-ins">Admission plugins</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="admission-plug-ins-about_admission-plug-ins">About admission plugins</h3>
<div class="paragraph">
<p>Admission plugins are used to help regulate how OpenShift Container Platform 4.13 functions. Admission plugins intercept requests to the master API to validate resource requests and ensure policies are adhered to, after the request is authenticated and authorized. For example, they are commonly used to enforce security policy, resource limitations or configuration requirements.</p>
</div>
<div class="paragraph">
<p>Admission plugins run in sequence as an admission chain. If any admission plugin in the sequence rejects a request, the whole chain is aborted and an error is returned.</p>
</div>
<div class="paragraph">
<p>OpenShift Container Platform has a default set of admission plugins enabled for each resource type. These are required for proper functioning of the cluster. Admission plugins ignore resources that they are not responsible for.</p>
</div>
<div class="paragraph">
<p>In addition to the defaults, the admission chain can be extended dynamically through webhook admission plugins that call out to custom webhook servers. There are two types of webhook admission plugins: a mutating admission plugin and a validating admission plugin. The mutating admission plugin runs first and can both modify resources and validate requests. The validating admission plugin validates requests and runs after the mutating admission plugin so that modifications triggered by the mutating admission plugin can also be validated.</p>
</div>
<div class="paragraph">
<p>Calling webhook servers through a mutating admission plugin can produce side effects on resources related to the target object. In such situations, you must take steps to validate that the end result is as expected.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Dynamic admission should be used cautiously because it impacts cluster control plane operations. When calling webhook servers through webhook admission plugins in OpenShift Container Platform 4.13, ensure that you have read the documentation fully and tested for side effects of mutations. Include steps to restore resources back to their original state prior to mutation, in the event that a request does not pass through the entire admission chain.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="admission-plug-ins-default_admission-plug-ins">Default admission plugins</h3>
<div class="paragraph">
<p>Default validating and admission plugins are enabled in OpenShift Container Platform 4.13. These default plugins contribute to fundamental control plane functionality, such as ingress policy, cluster resource limit override and quota policy. The following lists contain the default admission plugins:</p>
</div>
<details>
<summary class="title">Validating admission plugins</summary>
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>LimitRanger</code></p>
</li>
<li>
<p><code>ServiceAccount</code></p>
</li>
<li>
<p><code>PodNodeSelector</code></p>
</li>
<li>
<p><code>Priority</code></p>
</li>
<li>
<p><code>PodTolerationRestriction</code></p>
</li>
<li>
<p><code>OwnerReferencesPermissionEnforcement</code></p>
</li>
<li>
<p><code>PersistentVolumeClaimResize</code></p>
</li>
<li>
<p><code>RuntimeClass</code></p>
</li>
<li>
<p><code>CertificateApproval</code></p>
</li>
<li>
<p><code>CertificateSigning</code></p>
</li>
<li>
<p><code>CertificateSubjectRestriction</code></p>
</li>
<li>
<p><code>autoscaling.openshift.io/ManagementCPUsOverride</code></p>
</li>
<li>
<p><code>authorization.openshift.io/RestrictSubjectBindings</code></p>
</li>
<li>
<p><code>scheduling.openshift.io/OriginPodNodeEnvironment</code></p>
</li>
<li>
<p><code>network.openshift.io/ExternalIPRanger</code></p>
</li>
<li>
<p><code>network.openshift.io/RestrictedEndpointsAdmission</code></p>
</li>
<li>
<p><code>image.openshift.io/ImagePolicy</code></p>
</li>
<li>
<p><code>security.openshift.io/SecurityContextConstraint</code></p>
</li>
<li>
<p><code>security.openshift.io/SCCExecRestrictions</code></p>
</li>
<li>
<p><code>route.openshift.io/IngressAdmission</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateAPIServer</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateAuthentication</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateFeatureGate</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateConsole</code></p>
</li>
<li>
<p><code>operator.openshift.io/ValidateDNS</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateImage</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateOAuth</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateProject</code></p>
</li>
<li>
<p><code>config.openshift.io/DenyDeleteClusterConfiguration</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateScheduler</code></p>
</li>
<li>
<p><code>quota.openshift.io/ValidateClusterResourceQuota</code></p>
</li>
<li>
<p><code>security.openshift.io/ValidateSecurityContextConstraints</code></p>
</li>
<li>
<p><code>authorization.openshift.io/ValidateRoleBindingRestriction</code></p>
</li>
<li>
<p><code>config.openshift.io/ValidateNetwork</code></p>
</li>
<li>
<p><code>operator.openshift.io/ValidateKubeControllerManager</code></p>
</li>
<li>
<p><code>ValidatingAdmissionWebhook</code></p>
</li>
<li>
<p><code>ResourceQuota</code></p>
</li>
<li>
<p><code>quota.openshift.io/ClusterResourceQuota</code></p>
</li>
</ul>
</div>
</div>
</details>
<details>
<summary class="title">Mutating admission plugins</summary>
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>NamespaceLifecycle</code></p>
</li>
<li>
<p><code>LimitRanger</code></p>
</li>
<li>
<p><code>ServiceAccount</code></p>
</li>
<li>
<p><code>NodeRestriction</code></p>
</li>
<li>
<p><code>TaintNodesByCondition</code></p>
</li>
<li>
<p><code>PodNodeSelector</code></p>
</li>
<li>
<p><code>Priority</code></p>
</li>
<li>
<p><code>DefaultTolerationSeconds</code></p>
</li>
<li>
<p><code>PodTolerationRestriction</code></p>
</li>
<li>
<p><code>DefaultStorageClass</code></p>
</li>
<li>
<p><code>StorageObjectInUseProtection</code></p>
</li>
<li>
<p><code>RuntimeClass</code></p>
</li>
<li>
<p><code>DefaultIngressClass</code></p>
</li>
<li>
<p><code>autoscaling.openshift.io/ManagementCPUsOverride</code></p>
</li>
<li>
<p><code>scheduling.openshift.io/OriginPodNodeEnvironment</code></p>
</li>
<li>
<p><code>image.openshift.io/ImagePolicy</code></p>
</li>
<li>
<p><code>security.openshift.io/SecurityContextConstraint</code></p>
</li>
<li>
<p><code>security.openshift.io/DefaultSecurityContextConstraints</code></p>
</li>
<li>
<p><code>MutatingAdmissionWebhook</code></p>
</li>
</ul>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="admission-webhooks-about_admission-plug-ins">Webhook admission plugins</h3>
<div class="paragraph">
<p>In addition to OpenShift Container Platform default admission plugins, dynamic admission can be implemented through webhook admission plugins that call webhook servers, to extend the functionality of the admission chain. Webhook servers are called over HTTP at defined endpoints.</p>
</div>
<div class="paragraph">
<p>There are two types of webhook admission plugins in OpenShift Container Platform:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>During the admission process, the <em>mutating admission plugin</em> can perform tasks, such as injecting affinity labels.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>At the end of the admission process, the <em>validating admission plugin</em> can be used to make sure an object is configured properly, for example ensuring affinity labels are as expected. If the validation passes, OpenShift Container Platform schedules the object as configured.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an API request comes in, mutating or validating admission plugins use the list of external webhooks in the configuration and call them in parallel:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If all of the webhooks approve the request, the admission chain continues.</p>
</li>
<li>
<p>If any of the webhooks deny the request, the admission request is denied and the reason for doing so is based on the first denial.</p>
</li>
<li>
<p>If more than one webhook denies the admission request, only the first denial reason is returned to the user.</p>
</li>
<li>
<p>If an error is encountered when calling a webhook, the request is either denied or the webhook is ignored depending on the error policy set. If the error policy is set to <code>Ignore</code>, the request is unconditionally accepted in the event of a failure. If the policy is set to <code>Fail</code>, failed requests are denied. Using <code>Ignore</code> can result in unpredictable behavior for all clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Communication between the webhook admission plugin and the webhook server must use TLS. Generate a CA certificate and use the certificate to sign the server certificate that is used by your webhook admission server. The PEM-encoded CA certificate is supplied to the webhook admission plugin using a mechanism, such as service serving certificate secrets.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the sequential admission chain process within which multiple webhook servers are called.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/api-admission-chain.png" alt="API admission stage">
</div>
<div class="title">Figure 6. API admission chain with mutating and validating admission plugins</div>
</div>
<div class="paragraph">
<p>An example webhook admission plugin use case is where all pods must have a common set of labels. In this example, the mutating admission plugin can inject labels and the validating admission plugin can check that labels are as expected. OpenShift Container Platform would subsequently schedule pods that include required labels and reject those that do not.</p>
</div>
<div class="paragraph">
<p>Some common webhook admission plugin use cases include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Namespace reservation.</p>
</li>
<li>
<p>Limiting custom network resources managed by the SR-IOV network device plugin.</p>
</li>
<li>
<p>Defining tolerations that enable taints to qualify which pods should be scheduled on a node.</p>
</li>
<li>
<p>Pod priority class validation.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The maximum default webhook timeout value in OpenShift Container Platform is 13 seconds, and it cannot be changed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="admission-webhook-types_admission-plug-ins">Types of webhook admission plugins</h3>
<div class="paragraph">
<p>Cluster administrators can call out to webhook servers through the mutating admission plugin or the validating admission plugin in the API server admission chain.</p>
</div>
<div class="sect3">
<h4 id="mutating-admission-plug-in_admission-plug-ins">Mutating admission plugin</h4>
<div class="paragraph">
<p>The mutating admission plugin is invoked during the mutation phase of the admission process, which allows modification of resource content before it is persisted. One example webhook that can be called through the mutating admission plugin is the Pod Node Selector feature, which uses an annotation on a namespace to find a label selector and add it to the pod specification.</p>
</div>
<div id="mutating-admission-plug-in-config_admission-plug-ins" class="listingblock">
<div class="title">Sample mutating admission plugin configuration</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: admissionregistration.k8s.io/v1beta1
kind: MutatingWebhookConfiguration <b class="conum">(1)</b>
metadata:
  name: &lt;webhook_name&gt; <b class="conum">(2)</b>
webhooks:
- name: &lt;webhook_name&gt; <b class="conum">(3)</b>
  clientConfig: <b class="conum">(4)</b>
    service:
      namespace: default <b class="conum">(5)</b>
      name: kubernetes <b class="conum">(6)</b>
      path: &lt;webhook_url&gt; <b class="conum">(7)</b>
    caBundle: &lt;ca_signing_certificate&gt; <b class="conum">(8)</b>
  rules: <b class="conum">(9)</b>
  - operations: <b class="conum">(10)</b>
    - &lt;operation&gt;
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - &lt;resource&gt;
  failurePolicy: &lt;policy&gt; <b class="conum">(11)</b>
  sideEffects: None</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specifies a mutating admission plugin configuration.</p>
</li>
<li>
<p>The name for the <code>MutatingWebhookConfiguration</code> object. Replace <code>&lt;webhook_name&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>The name of the webhook to call. Replace <code>&lt;webhook_name&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>Information about how to connect to, trust, and send data to the webhook server.</p>
</li>
<li>
<p>The namespace where the front-end service is created.</p>
</li>
<li>
<p>The name of the front-end service.</p>
</li>
<li>
<p>The webhook URL used for admission requests. Replace <code>&lt;webhook_url&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server.  Replace <code>&lt;ca_signing_certificate&gt;</code> with the appropriate certificate in base64 format.</p>
</li>
<li>
<p>Rules that define when the API server should use this webhook admission plugin.</p>
</li>
<li>
<p>One or more operations that trigger the API server to call this webhook admission plugin. Possible values are <code>create</code>, <code>update</code>, <code>delete</code> or <code>connect</code>. Replace <code>&lt;operation&gt;</code> and <code>&lt;resource&gt;</code> with the appropriate values.</p>
</li>
<li>
<p>Specifies how the policy should proceed if the webhook server is unavailable.
Replace <code>&lt;policy&gt;</code> with either <code>Ignore</code> (to unconditionally accept the request in the event of a failure) or <code>Fail</code> (to deny the failed request). Using <code>Ignore</code> can result in unpredictable behavior for all clients.</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>In OpenShift Container Platform 4.13, objects created by users or control loops through a mutating admission plugin might return unexpected results, especially if values set in an initial request are overwritten, which is not recommended.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="validating-admission-plug-in_admission-plug-ins">Validating admission plugin</h4>
<div class="paragraph">
<p>A validating admission plugin is invoked during the validation phase of the admission process. This phase allows the enforcement of invariants on particular API resources to ensure that the resource does not change again. The Pod Node Selector is also an example of a webhook which is called by the validating admission plugin, to ensure that all <code>nodeSelector</code> fields are constrained by the node selector restrictions on the namespace.</p>
</div>
<div id="validating-admission-plug-in-config_admission-plug-ins" class="listingblock">
<div class="title">Sample validating admission plugin configuration</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration <b class="conum">(1)</b>
metadata:
  name: &lt;webhook_name&gt; <b class="conum">(2)</b>
webhooks:
- name: &lt;webhook_name&gt; <b class="conum">(3)</b>
  clientConfig: <b class="conum">(4)</b>
    service:
      namespace: default  <b class="conum">(5)</b>
      name: kubernetes <b class="conum">(6)</b>
      path: &lt;webhook_url&gt; <b class="conum">(7)</b>
    caBundle: &lt;ca_signing_certificate&gt; <b class="conum">(8)</b>
  rules: <b class="conum">(9)</b>
  - operations: <b class="conum">(10)</b>
    - &lt;operation&gt;
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - &lt;resource&gt;
  failurePolicy: &lt;policy&gt; <b class="conum">(11)</b>
  sideEffects: Unknown</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specifies a validating admission plugin configuration.</p>
</li>
<li>
<p>The name for the <code>ValidatingWebhookConfiguration</code> object. Replace <code>&lt;webhook_name&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>The name of the webhook to call. Replace <code>&lt;webhook_name&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>Information about how to connect to, trust, and send data to the webhook server.</p>
</li>
<li>
<p>The namespace where the front-end service is created.</p>
</li>
<li>
<p>The name of the front-end service.</p>
</li>
<li>
<p>The webhook URL used for admission requests. Replace <code>&lt;webhook_url&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server.  Replace <code>&lt;ca_signing_certificate&gt;</code> with the appropriate certificate in base64 format.</p>
</li>
<li>
<p>Rules that define when the API server should use this webhook admission plugin.</p>
</li>
<li>
<p>One or more operations that trigger the API server to call this webhook admission plugin. Possible values are <code>create</code>, <code>update</code>, <code>delete</code> or <code>connect</code>. Replace <code>&lt;operation&gt;</code> and <code>&lt;resource&gt;</code> with the appropriate values.</p>
</li>
<li>
<p>Specifies how the policy should proceed if the webhook server is unavailable.
Replace <code>&lt;policy&gt;</code> with either <code>Ignore</code> (to unconditionally accept the request in the event of a failure) or <code>Fail</code> (to deny the failed request). Using <code>Ignore</code> can result in unpredictable behavior for all clients.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-dynamic-admission_admission-plug-ins">Configuring dynamic admission</h3>
<div class="paragraph">
<p>This procedure outlines high-level steps to configure dynamic admission. The functionality of the admission chain is extended by configuring a webhook admission plugin to call out to a webhook server.</p>
</div>
<div class="paragraph">
<p>The webhook server is also configured as an aggregated API server. This allows other OpenShift Container Platform components to communicate with the webhook using internal credentials and facilitates testing using the <code>oc</code> command. Additionally, this enables role based access control (RBAC) into the webhook and prevents token information from other API servers from being disclosed to the webhook.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>An OpenShift Container Platform account with cluster administrator access.</p>
</li>
<li>
<p>The OpenShift Container Platform CLI (<code>oc</code>) installed.</p>
</li>
<li>
<p>A published webhook server container image.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Build a webhook server container image and make it available to the cluster using an image registry.</p>
</li>
<li>
<p>Create a local CA key and certificate and use them to sign the webhook server&#8217;s certificate signing request (CSR).</p>
</li>
<li>
<p>Create a new project for webhook resources:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc new-project my-webhook-namespace  <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that the webhook server might expect a specific name.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Define RBAC rules for the aggregated API service in a file called <code>rbac.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: List
items:

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(1)</b>
  kind: ClusterRoleBinding
  metadata:
    name: auth-delegator-my-webhook-namespace
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: system:auth-delegator
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(2)</b>
  kind: ClusterRole
  metadata:
    annotations:
    name: system:openshift:online:my-webhook-server
  rules:
  - apiGroups:
    - online.openshift.io
    resources:
    - namespacereservations  <b class="conum">(3)</b>
    verbs:
    - get
    - list
    - watch

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(4)</b>
  kind: ClusterRole
  metadata:
    name: system:openshift:online:my-webhook-requester
  rules:
  - apiGroups:
    - admission.online.openshift.io
    resources:
    - namespacereservations <b class="conum">(5)</b>
    verbs:
    - create

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(6)</b>
  kind: ClusterRoleBinding
  metadata:
    name: my-webhook-server-my-webhook-namespace
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: system:openshift:online:my-webhook-server
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(7)</b>
  kind: RoleBinding
  metadata:
    namespace: kube-system
    name: extension-server-authentication-reader-my-webhook-namespace
  roleRef:
    kind: Role
    apiGroup: rbac.authorization.k8s.io
    name: extension-apiserver-authentication-reader
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <b class="conum">(8)</b>
  kind: ClusterRole
  metadata:
    name: my-cluster-role
  rules:
  - apiGroups:
    - admissionregistration.k8s.io
    resources:
    - validatingwebhookconfigurations
    - mutatingwebhookconfigurations
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - namespaces
    verbs:
    - get
    - list
    - watch

- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: my-cluster-role
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: my-cluster-role
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Delegates authentication and authorization to the webhook server API.</p>
</li>
<li>
<p>Allows the webhook server to access cluster resources.</p>
</li>
<li>
<p>Points to resources. This example points to the <code>namespacereservations</code> resource.</p>
</li>
<li>
<p>Enables the aggregated API server to create admission reviews.</p>
</li>
<li>
<p>Points to resources. This example points to the <code>namespacereservations</code> resource.</p>
</li>
<li>
<p>Enables the webhook server to access cluster resources.</p>
</li>
<li>
<p>Role binding to read the configuration for terminating authentication.</p>
</li>
<li>
<p>Default cluster role and cluster role bindings for an aggregated API server.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Apply those RBAC rules to the cluster:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc auth reconcile -f rbac.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Create a YAML file called <code>webhook-daemonset.yaml</code> that is used to deploy a webhook as a daemon set server in a namespace:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: my-webhook-namespace
  name: server
  labels:
    server: "true"
spec:
  selector:
    matchLabels:
      server: "true"
  template:
    metadata:
      name: server
      labels:
        server: "true"
    spec:
      serviceAccountName: server
      containers:
      - name: my-webhook-container  <b class="conum">(1)</b>
        image: &lt;image_registry_username&gt;/&lt;image_path&gt;:&lt;tag&gt;  <b class="conum">(2)</b>
        imagePullPolicy: IfNotPresent
        command:
        - &lt;container_commands&gt;  <b class="conum">(3)</b>
        ports:
        - containerPort: 8443 <b class="conum">(4)</b>
        volumeMounts:
        - mountPath: /var/serving-cert
          name: serving-cert
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8443 <b class="conum">(5)</b>
            scheme: HTTPS
      volumes:
      - name: serving-cert
        secret:
          defaultMode: 420
          secretName: server-serving-cert</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Note that the webhook server might expect a specific container name.</p>
</li>
<li>
<p>Points to a webhook server container image. Replace <code>&lt;image_registry_username&gt;/&lt;image_path&gt;:&lt;tag&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>Specifies webhook container run commands. Replace <code>&lt;container_commands&gt;</code> with the appropriate value.</p>
</li>
<li>
<p>Defines the target port within pods. This example uses port 8443.</p>
</li>
<li>
<p>Specifies the port used by the readiness probe. This example uses port 8443.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Deploy the daemon set:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-daemonset.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Define a secret for the service serving certificate signer, within a YAML file called <code>webhook-secret.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  namespace: my-webhook-namespace
  name: server-serving-cert
type: kubernetes.io/tls
data:
  tls.crt: &lt;server_certificate&gt;  <b class="conum">(1)</b>
  tls.key: &lt;server_key&gt;  <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>References the signed webhook server certificate. Replace <code>&lt;server_certificate&gt;</code> with the appropriate certificate in base64 format.</p>
</li>
<li>
<p>References the signed webhook server key. Replace <code>&lt;server_key&gt;</code> with the appropriate key in base64 format.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Create the secret:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-secret.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Define a service account and service, within a YAML file called <code>webhook-service.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: List
items:

- apiVersion: v1
  kind: ServiceAccount
  metadata:
    namespace: my-webhook-namespace
    name: server

- apiVersion: v1
  kind: Service
  metadata:
    namespace: my-webhook-namespace
    name: server
    annotations:
      service.beta.openshift.io/serving-cert-secret-name: server-serving-cert
  spec:
    selector:
      server: "true"
    ports:
    - port: 443  <b class="conum">(1)</b>
      targetPort: 8443  <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Defines the port that the service listens on. This example uses port 443.</p>
</li>
<li>
<p>Defines the target port within pods that the service forwards connections to. This example uses port 8443.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Expose the webhook server within the cluster:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-service.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Define a custom resource definition for the webhook server, in a file called <code>webhook-crd.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: namespacereservations.online.openshift.io  <b class="conum">(1)</b>
spec:
  group: online.openshift.io  <b class="conum">(2)</b>
  version: v1alpha1  <b class="conum">(3)</b>
  scope: Cluster  <b class="conum">(4)</b>
  names:
    plural: namespacereservations  <b class="conum">(5)</b>
    singular: namespacereservation  <b class="conum">(6)</b>
    kind: NamespaceReservation  <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Reflects <code>CustomResourceDefinition</code> <code>spec</code> values and is in the format <code>&lt;plural&gt;.&lt;group&gt;</code>. This example uses the <code>namespacereservations</code> resource.</p>
</li>
<li>
<p>REST API group name.</p>
</li>
<li>
<p>REST API version name.</p>
</li>
<li>
<p>Accepted values are <code>Namespaced</code> or <code>Cluster</code>.</p>
</li>
<li>
<p>Plural name to be included in URL.</p>
</li>
<li>
<p>Alias seen in <code>oc</code> output.</p>
</li>
<li>
<p>The reference for resource manifests.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Apply the custom resource definition:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-crd.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Configure the webhook server also as an aggregated API server, within a file called <code>webhook-api-service.yaml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: apiregistration.k8s.io/v1beta1
kind: APIService
metadata:
  name: v1beta1.admission.online.openshift.io
spec:
  caBundle: &lt;ca_signing_certificate&gt;  <b class="conum">(1)</b>
  group: admission.online.openshift.io
  groupPriorityMinimum: 1000
  versionPriority: 15
  service:
    name: server
    namespace: my-webhook-namespace
  version: v1beta1</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server. Replace <code>&lt;ca_signing_certificate&gt;</code> with the appropriate certificate in base64 format.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Deploy the aggregated API service:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-api-service.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Define the webhook admission plugin configuration within a file called <code>webhook-config.yaml</code>. This example uses the validating admission plugin:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-yaml" data-lang="yaml">apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration
metadata:
  name: namespacereservations.admission.online.openshift.io  <b class="conum">(1)</b>
webhooks:
- name: namespacereservations.admission.online.openshift.io  <b class="conum">(2)</b>
  clientConfig:
    service:  <b class="conum">(3)</b>
      namespace: default
      name: kubernetes
      path: /apis/admission.online.openshift.io/v1beta1/namespacereservations  <b class="conum">(4)</b>
    caBundle: &lt;ca_signing_certificate&gt;  <b class="conum">(5)</b>
  rules:
  - operations:
    - CREATE
    apiGroups:
    - project.openshift.io
    apiVersions:
    - "*"
    resources:
    - projectrequests
  - operations:
    - CREATE
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - namespaces
  failurePolicy: Fail</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Name for the <code>ValidatingWebhookConfiguration</code> object. This example uses the <code>namespacereservations</code> resource.</p>
</li>
<li>
<p>Name of the webhook to call. This example uses the <code>namespacereservations</code> resource.</p>
</li>
<li>
<p>Enables access to the webhook server through the aggregated API.</p>
</li>
<li>
<p>The webhook URL used for admission requests. This example uses the <code>namespacereservation</code> resource.</p>
</li>
<li>
<p>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server. Replace <code>&lt;ca_signing_certificate&gt;</code> with the appropriate certificate in base64 format.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Deploy the webhook:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-terminal" data-lang="terminal">$ oc apply -f webhook-config.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Verify that the webhook is functioning as expected. For example, if you have configured dynamic admission to reserve specific namespaces, confirm that requests to create those namespaces are rejected and that requests to create non-reserved namespaces succeed.</p>
</li>
</ol>
</div>
</div>
<div class="sect2 _additional-resources">
<h3 id="admission-plug-ins-additional-resources">Additional resources</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/networking/#configuring-sriov-operator">Limiting custom network resources managed by the SR-IOV network device plugin</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/nodes/#nodes-scheduler-taints-tolerations_dedicating_nodes-scheduler-taints-tolerations">Defining tolerations that enable taints to qualify which pods should be scheduled on a node</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/nodes/#admin-guide-priority-preemption-names_nodes-pods-priority">Pod priority class validation</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-07-20 15:16:17 UTC
</div>
</div>
</body>
</html>